% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the % conditions of
% the LaTeX Project Public License, either version 1.3 % of this license
% or (at your option) any later version. % The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrih.
%
% This work consists of the files cloze.dtx and cloze.ins
% and the derived filebase cloze.sty.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{cloze.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{cloze}
%<*package>
    [2015/06/16 v0.1 Package to typeset cloze worksheets or cloze tests]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage[show]{cloze}
\usepackage{paralist}
\usepackage[
  colorlinks=true,
  linkcolor=red,
  filecolor=red,
  urlcolor=red,
]{hyperref}


\MakeShortVerb{\|}

\setlength{\fboxrule}{0.2pt}
\setlength{\fboxsep}{8pt}

\makeatletter
\newcommand{\@minipagerestore}{\setlength{\parindent}{10pt}}
\makeatother

\newsavebox{\examplebox}
\newenvironment{clozeexample}{%
  \medskip%
  \begin{lrbox}{\examplebox}%
  \begin{minipage}{294pt}%
}{%
  \end{minipage}%
  \end{lrbox}%
  \noindent%
  \hspace{24pt}%
  \fbox{\usebox{\examplebox}}%
  \medskip%
}

\newcommand{\getdefaults}[1]{%
  \directlua{tex.print(cloze.get_defaults('#1'))}%
}

\newcommand{\expdesc}[1]{(|#1|)}

\newcommand{\desc}[1]{%
  \hfill%
  \expdesc{#1}%
  \par%
}

\def\tt#1{\texttt{#1}}

\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{cloze.dtx}
\title{The \cloze{cloze} package\thanks{Robert-Michael Huber, Paul Isambert}}
\author{Josef Friedrich\\ \url{josef@friedrich.rocks}}
\date{\fileversion~from \filedate}


\maketitle

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\tableofcontents

%-----------------------------------------------------------------------
% Introduction
%-----------------------------------------------------------------------

\section{Introduction}

\emph{cloze} is a \LaTeX{} package to generate cloze texts. It uses
the capabilities of the modern \TeX{} engine \emph{Lua\TeX}. Therefor
you must use Lua\LaTeX{} to produce documents containing clozes.

The main feature of the package is, that you can freely show and hide
the cloze text without changing the position of any other letter.

\newcommand{\clozelorem}{%
Lorem ipsum \cloze{dolor sit} amet, consectetur \cloze{adipisicing}
elit, sed do eiusmod tempor incididunt ut labore et \cloze{dolore magna}
aliqua. Ut enim ad minim veniam, quis nostrud \cloze{exercitation}
ullamco laboris nisi ut \cloze{aliquip} ex ea commodo consequat.%
}

\begin{clozeexample}
\clozelorem
\end{clozeexample}

\setcloze{hide}

The command |\setcloze{hide}| will only show gaps and cloze lines, not
the cloze text. You can put the two boxes above and below to each
other and they will fit perfectly.

\begin{clozeexample}
\clozelorem
\end{clozeexample}

\setcloze{show}

%-----------------------------------------------------------------------
% Usage
%-----------------------------------------------------------------------

\section{Usage}

At the moment there are three commands and one environment to generate
cloze text: \cmd{\cloze}, \cmd{\clozefix}, \cmd{\clozefil} and
|clozepar|.

%%
% \cloze
%%

\subsection{Command \cmd{\cloze}}

\DescribeMacro{\cloze} \cmd{\cloze}\oarg{options}\marg{some text}: The
command \cmd{\cloze} behaves similar to a command that underlines the
text. \cmd{\cloze} does not prevent line breaks. The width of a cloze is
pending on the number of letters and the font used. The only option
which affects the widths of a cloze is the option |margin|.
\ref{sec:option-margin}

\begin{clozeexample}
Lorem ipsum \cloze{dolor} sit amet, \cloze{consectetur} adipisicing
elit, sed do eiusmod tempor incididunt ut labore et dolore
\cloze{magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi} ut aliquip ex ea commodo consequat.
\end{clozeexample}

\DescribeMacro{\clozefont} The cloze font can be changed by redefining
the command \cmd{\clozefont}, e. g.

\renewcommand{\clozefont}{\Large}
|\renewcommand{\clozefont}{\Large}|

\begin{clozeexample}
Excepteur \cloze{sint} occaecat \cloze{cupidatat} non proident.
\end{clozeexample}

\renewcommand{\clozefont}{\ttfamily\normalsize}
|\renewcommand{\clozefont}{\ttfamily\normalsize}|

\begin{clozeexample}
Excepteur \cloze{sint} occaecat \cloze{cupidatat} non proident.
\end{clozeexample}
\renewcommand{\clozefont}{\itshape}

%%
% \clozefix
%%

\subsection{Command \cmd{\clozefix}}

\DescribeMacro{\clozefix} \cmd{\clozefix}\oarg{options}\marg{some text}:
The command \cmd{\clozefix} produces clozes with a fixed width. The
clozes are by default \tt{\getdefaults{width}} wide.


\begin{clozeexample}
\noindent Lorem ipsum dolor sit amet:
\begin{compactenum}
\item \clozefix[width=5cm]{consectetur}
\item \clozefix[width=5cm]{adipisicing}
\item \clozefix[width=5cm]{elit}
\end{compactenum}
sed do eiusmod.
\end{clozeexample}

%%
% \clozefil
%%

\subsection{Command \cmd{\clozefil}}
\DescribeMacro{\clozefil} \cmd{\clozefil}\oarg{options}\marg{some text}:


\begin{clozeexample}
Lorem ipsum dolor sit amet, \clozefil{consectetur adipisicing elit, sed
do eiusmod.}
e
Ut enim \clozefil{ad minim veniam} exercitation.
\end{clozeexample}

%%
% clozepar
%%

\subsection{Environment \tt{clozepar}}
\DescribeEnv{clozepar} |\begin{clozepar}|\oarg{options} \dots
\textit{some text} \dots |\end{clozepar}|: The environment \tt{clozepar}
transforms a complete paragraph into a cloze. The options |align|,
|margin| and |width| have no effect on this environment.

\begin{clozeexample}
Lorem ipsum dolor sit amet, consectetur adipisicing elit ullamco laboris
nisi.

\begin{clozepar}
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi
ut aliquip ex ea commodo consequat. Duis aute irure dolor in
reprehenderit in voluptate velit esse cillum.
\end{clozepar}

Excepteur sint occaecat cupidatat non proident.
\end{clozeexample}

\DescribeMacro{\clozelinefil}

%-----------------------------------------------------------------------
% Options
%-----------------------------------------------------------------------

\section{The options}
\DescribeMacro{\setcloze}

%%
% align
%%

\subsection{The option \tt{align}}

Only the macro \cmd{\clozefix} takes the option \texttt{align} into
account. Possible values are \texttt{left}, \texttt{center} and
\texttt{right}. This option only makes sense, if the width of the
cloze line is larger than the width of the cloze text.

\newcommand{\optionsalign}[1]{%
  \noindent%
  \clozefix[align=#1,width=8cm]{Lorem ipsum}%
  \desc{#1}%
}

\begin{clozeexample}
\optionsalign{left}
\optionsalign{center}
\optionsalign{right}
\end{clozeexample}

%%
% distance
%%

\subsection{The option \tt{distance}}

\newcommand{\optiondistance}[1]{%
  \noindent%
  \clozefil[distance=#1]{Lorem ipsum dolor sit amet.}
  \expdesc{#1}
  \par%
}

\begin{clozeexample}
\optiondistance{\getdefaults{distance}}
\optiondistance{3pt}
\optiondistance{-3pt}
\end{clozeexample}

%%
% hide and show
%%

\subsection{The options \tt{hide} and \tt{show}}

The cloze text is displayed by default. Use the option \texttt{hide} to
remove the cloze text from the output.  If you accidentally specify both
options, the last option "wins".

\newcommand{\optionshow}[1]{%
  \noindent%
  Lorem ipsum \cloze[#1]{dolor sit amet}, consectetur
  \cloze[#1]{adipisicing} elit.%
  \desc{#1}%
}

\begin{clozeexample}
\optionshow{hide}
\optionshow{show}
\end{clozeexample}

%%
% linecolor and textcolor
%%

\subsection{The options \tt{linecolor} and \tt{textcolor}}

Values for both color options are color names used by the xcolor
package. To define your own color use the following command:

|\definecolor{myclozecolor}{rgb}{0.1,0.4,0.6}|
\definecolor{myclozecolor}{rgb}{0.1,0.4,0.6}

\newcommand{\optioncolor}[2]{%
  \clozefil[#1=#2]{Lorem ipsum dolor sit amet, consectetur} %
  \expdesc{#2}%
  \par%
}

\begin{clozeexample}
\optioncolor{textcolor}{myclozecolor}
\optioncolor{textcolor}{red}
\optioncolor{textcolor}{green}
\end{clozeexample}

You can use the same color names to colorize the cloze lines.

\begin{clozeexample}
\optioncolor{linecolor}{myclozecolor}
\optioncolor{linecolor}{red}
\optioncolor{linecolor}{green}
\end{clozeexample}

%%
% margin
%%

\subsection{The option \tt{margin}}\label{sec:option-margin}

The option |margin| indicates how far the cloze line sticks up from the
cloze text. The option can be used with the commands \cmd{\cloze},
\cmd{\clozefix} and \cmd{\clozefil}.

\newcommand{\optionmargin}[1]{%
  Lorem ipsum \cloze[margin=#1]{dolor} sit amet.%
  \desc{#1}%
}

\begin{clozeexample}
\optionmargin{0pt}
\optionmargin{5mm}
\optionmargin{1cm}
\optionmargin{6em}
\optionmargin{-4pt}
\end{clozeexample}


%%
% thickness
%%

\subsection{The option \tt{thickness}}

\newcommand{\optionthickness}[1]{%
  Lorem \cloze[thickness=#1]{ipsum dolor sit} amet.%
  \desc{#1}%
}

\begin{clozeexample}
\optionthickness{0.01pt}
\optionthickness{1pt}
\optionthickness{2pt}
\end{clozeexample}


%%
% width
%%

\subsection{The option \tt{width}}

\newcommand{\optionwidth}[1]{%
  Lorem \clozefix[width=#1]{dolor} amet.%
  \desc{#1}%
}

\begin{clozeexample}
\optionwidth{3cm}
\optionwidth{5cm}
\optionwidth{7cm}
\end{clozeexample}



  \DocInput{cloze.dtx}
  \PrintChanges
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# Description

EN: `cloze` is a LaTeX package to generate cloze. It uses the
capabilities of the modern TeX engine LuaTex.

DE: `cloze` ist a LaTeX-Paket zum Erstellen von Lückentexten. Es nutzt
die Möglichkeiten der modernen TeX-Engine LuaTeX.

# Repository

https://github.com/Josef-Friedrich/cloze

# Installation

Get source:

    git clone git@github.com:Josef-Friedrich/cloze.git
    cd cloze

Compile:

    make

or manually:

    luatex cloze.ins
    lualatex cloze.dtx
    makeindex -s gglo.ist -o cloze.gls cloze.glo
    makeindex -s gind.ist -o cloze.ind cloze.idx
    lualatex cloze.dtx

%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% \subsection{The file \tt{cloze.sty}}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{cloze}
\RequirePackage{luatexbase-mcb}
\RequirePackage{xcolor}
\RequirePackage{kvoptions}
\directlua{
  cloze = require("cloze")
}
%    \end{macrocode}
%
%
% \subsubsection{Internal macros}
%
%
% \begin{macro}{\cloze@set@to@global}
%    \begin{macrocode}
\def\cloze@set@to@global{%
 \directlua{cloze.set_is_global(true)}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@to@local}
%    \begin{macrocode}
\def\cloze@set@to@local{%
  \directlua{
  cloze.unset_local_options()
  cloze.set_is_global(false)
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@option}
%    \begin{macrocode}
\def\cloze@set@option[#1]#2{%
  \directlua{cloze.set_option('#1', '#2')}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@color}
%    \begin{macrocode}
\def\cloze@color#1{\csname\string\color@#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@local@options}
%    \begin{macrocode}
\def\cloze@set@local@options#1{%
  \cloze@set@to@local%
  \kvsetkeys{LC}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@start@marker}
%    \begin{macrocode}
\def\cloze@start@marker#1{%
  \strut\directlua{
    cloze.register('#1')
    cloze.marker('#1', 'start')
    cloze.process_options()
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@stop@marker}
%    \begin{macrocode}
\def\cloze@stop@marker#1{%
  \strut\directlua{
    cloze.marker('#1', 'stop')
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@margin}
%    \begin{macrocode}
\def\cloze@margin#1{%
  \directlua{cloze.margin()}%
  #1%
  \directlua{cloze.margin()}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Options}
%
%    \begin{macrocode}
\cloze@set@to@global
%    \end{macrocode}
% LC = cloze
%    \begin{macrocode}
\SetupKeyvalOptions{
  family=LC,
  prefix=LC@
}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{align}}
%
%    \begin{macrocode}
\DeclareStringOption{align} % Affects only \clozefix
\define@key{LC}{align}[]{\cloze@set@option[align]{#1}}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{distance}}
%
%    \begin{macrocode}
\DeclareStringOption{distance}
\define@key{LC}{distance}[]{\cloze@set@option[distance]{#1}}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{hide}}
%
%    \begin{macrocode}
\DeclareVoidOption{hide}{%
  \cloze@set@option[hide]{true}%
  \cloze@set@option[show]{false}%
}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{linecolor}}
%
%    \begin{macrocode}
\DeclareStringOption{linecolor}
\define@key{LC}{linecolor}[]{\cloze@set@option[linecolor]{\cloze@color{#1}}}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{margin}}
%
%    \begin{macrocode}
\DeclareStringOption{margin}
\define@key{LC}{margin}[]{\cloze@set@option[margin]{#1}}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{show}}
%
%    \begin{macrocode}
\DeclareVoidOption{show}{%
  \cloze@set@option[show]{true}%
  \cloze@set@option[hide]{false}%
}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{textcolor}}
%
%    \begin{macrocode}
\DeclareStringOption{textcolor}
\define@key{LC}{textcolor}[]{\cloze@set@option[textcolor]{\cloze@color{#1}}}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{thickness}}
%
%    \begin{macrocode}
\DeclareStringOption{thickness}
\define@key{LC}{thickness}[]{\cloze@set@option[thickness]{#1}}
%    \end{macrocode}
%
%
% \paragraph{The option \tt{width}}
%    \begin{macrocode}
\DeclareStringOption{width} % Affects only \clozefix
\define@key{LC}{width}[]{\cloze@set@option[width]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyvalOptions{LC}
%    \end{macrocode}
%
% \subsubsection{Public macros}
%
% \begin{macro}{\setcloze}
%    \begin{macrocode}
\newcommand{\setcloze}[1]{%
  \cloze@set@to@global%
  \kvsetkeys{LC}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozefont}
%    \begin{macrocode}
\newcommand{\clozefont}{\itshape}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze}
%    \begin{macrocode}
\newcommand{\cloze}[2][]{%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{basic}%
  {%
    \clozefont%
    \cloze@margin{#2}%
  }%
  \cloze@stop@marker{basic}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozefix}
% Creates a cloze on one line with a fixed length.
%    \begin{macrocode}
\newcommand{\clozefix}[2][]{%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{fix}%
  {%
    \clozefont%
    \cloze@margin{#2}%
  }%
  \cloze@stop@marker{fix}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{environment}{clozepar}
%    \begin{macrocode}
\newenvironment{clozepar}[1][]%
{%
  \par%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{par}%
  \clozefont%
}%
{%
  \cloze@stop@marker{par}%
  \par%
  \directlua{cloze.unregister('par')}%
}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{macro}{\clozefil}
%    \begin{macrocode}
\newcommand{\clozefil}[2][]{%
  \cloze[#1]{#2}\clozelinefil[#1]%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozelinefil}
% Creates a cloze on one line with a fixed length.
%    \begin{macrocode}
\newcommand{\clozelinefil}[1][]{%
  \cloze@set@local@options{#1}%
  \strut
  \directlua{cloze.hfill()}%
  \strut
}
%    \end{macrocode}
% \end{macro}
%
%
% \iffalse
%</package>
%<*lua>
% \fi
% \subsection{The file \tt{cloze.lua}}
%    \begin{macrocode}
local check = {}
check.user_id = 3121978

local get = {}
local create = {}
local insert = {}

local registry = {}
registry.storage = {}
registry.defaults = {
  ['align'] = 'l',
  ['distance'] = '1.5pt',
  ['linecolor'] = '0 0 0 rg 0 0 0 RG', -- black
  ['margin'] = '3pt',
  ['resetcolor'] = '0 0 0 rg 0 0 0 RG', -- black
  ['show_text'] = true,
  ['textcolor'] = '0 0 1 rg 0 0 1 RG', -- blue
  ['thickness'] = '0.1pt',
  ['width'] = '2cm',
}
registry.global_options = {}
registry.local_options = {}
registry.options = {}

local cloze = {}
local base = {}
local is_registered = {}

local options
%    \end{macrocode}
% \subsubsection{Check functions}
%    \begin{macrocode}
function check.whatsit_marker(item)
  if item.id == node.id('whatsit')
      and item.subtype == 44
      and item.user_id == check.user_id then
    return true
  else
    return false
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function check.marker(item, mode, position)
  local data = registry.marker_data(item)

  if data and data.mode == mode and data.position == position then
    return true
  else
    return false
  end
end
%    \end{macrocode}
% \subsubsection{Create functions}
%    \begin{macrocode}
function create.whatsit_colorstack(data)
  if not data then
    -- black
    data = '0 0 0 rg 0 0 0 RG'
  end

  local node = node.new('whatsit', 'pdf_colorstack')
  node.stack = 0
  node.data = data

  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.color(option)
  local data

  if option == 'line' then
    data = registry.linecolor
  elseif option == 'text' then
    data = registry.textcolor
  elseif option == 'reset' then
    data = nil
  else
    data = nil
  end

  return create.whatsit_colorstack(data)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.rule(width)
  local node = node.new(node.id('rule'))
  local thickness = tex.sp(registry.thickness)
  local distance = tex.sp(registry.distance)

  node.depth = distance + thickness
  node.height = - distance
  node.width = width

  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.kern(kern)
  local node = node.new(node.id('kern'))
  node.kern = kern
  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.glyph()
  local node = node.new(node.id('glyph'))
  node.char = 34
  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.marker(index)
  local marker = node.new('whatsit','user_defined')
  marker.type = 100 -- number
  marker.user_id = check.user_id
  marker.value = index

  return marker
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.hfill()
  local glue = node.new('glue')
  glue.subtype = 100

  local glue_spec = node.new('glue_spec')
  glue_spec.stretch = 65536
  glue_spec.stretch_order = 3

  glue.spec = glue_spec

  local rule = create.rule(0)
  rule.dir = 'TLT'

  glue.leader = rule

  return glue
end
%    \end{macrocode}
%
% \subsubsection{Insert functions}
%
%    \begin{macrocode}
function insert.hfill()
  registry.process_options()
  node.write(create.color('line'))
  node.write(create.hfill())
  node.write(create.color('reset'))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function insert.margin()
  local kern = create.kern(tex.sp(registry.margin))
  node.write(kern)
end
%    \end{macrocode}
% Append rule and kern to the node list.
%    \begin{macrocode}
function insert.rule_colored(head, current, width)
  local rule = create.rule(width)

  head, new = node.insert_after(head, current, create.color('line'))
  head, new = node.insert_after(head, new, rule)
  head, new = node.insert_after(head, new, create.color('reset'))

  return head, new
end
%    \end{macrocode}
%
% \subsubsection{registry}
%
% Functions to deal with option handling and storing them in a lua
% table.
%
%    \begin{macrocode}
function registry.get_index()
  if not registry.index then
    registry.index = 0
  end

  registry.index = registry.index + 1
  return registry.index
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_option(key, value)
  if value == '' or value == '\\color@ ' then
    return false
  end

  if registry.is_global == true then
    registry.global_options[key] = value
  else
    registry.local_options[key] = value
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_is_global(value)
  registry.is_global = value
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.unset_local_options()
  registry.local_options = {}
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set(mode, position)
  local index = registry.get_index()

  local data = {
    ['mode'] = mode,
    ['position'] = position
  }

  if registry.local_options then
    local cleaned_values = {}
    for key, value in pairs(registry.local_options) do
      if value ~= '' then
        cleaned_values[key] = value
      end
    end
    data.values = cleaned_values
  end

  registry.storage[index] = data
  return index
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get(index)
  return registry.storage[index]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_show_text(options)
  if not options then
    return nil
  end

  if options.hide == true or options.hide == 'true'  then
    return false
  elseif options.show == true or options.show == 'true'  then
    return true
  else
    return nil
  end
end
%    \end{macrocode}
% Unset options which have the values '|unset|' or '|\color@ |'.
%    \begin{macrocode}

function registry.merge_local_options()
  if registry.local_options then
    registry.options = registry.local_options
  else
    registry.options = {}
  end
  registry.options.show_text = registry.set_show_text(registry.local_options)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.merge_global_options()
  registry.global_options.show_text = registry.set_show_text(registry.global_options)

  for key, value in pairs(registry.global_options) do
    if registry.options[key] == nil or registry.options[key] == '' then
      registry.options[key] = value
    end
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.merge_defaults()
  for key, value in pairs(registry.defaults) do
    if registry.options[key] == nil or registry.options[key] == '' then
      registry.options[key] = value
    end
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.fix_align_options()
  local align = string.lower(registry.options.align)
  local result

  if align == 'r' then
    result = 'right'
  elseif align == 'c' then
    result = 'center'
  elseif align == 'l' then
    result = 'left'
  else
    result = align
  end

  registry.options.align = align
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.move_to_base()
  for key, value in pairs(registry.options) do
    registry[key] = value
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.debug(table, identifier)
  for key, value in pairs(table) do
    print(identifier .. ' KEY: ' .. tostring(key) .. ' VALUE: ' .. tostring(value))
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.process_options()
  registry.merge_local_options()
  registry.merge_global_options()
  registry.merge_defaults()
  registry.fix_align_options()
  registry.move_to_base()
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.marker_data(item)
  if not check.whatsit_marker(item) then
    return false
  else
    return registry.get(item.value)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.marker_values(item)
  local data = registry.marker_data(item)
  registry.local_options = data.values
  return data.values
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_marker(item, mode, position)
  local out

  if check.marker(item, mode, position) then
    registry.marker = item
    out = item
  else
    out = false
  end

  if out and position == 'start' then
    registry.marker_values(item)
    registry.process_options()
  end

  return out
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_defaults(key)
  return registry.defaults[key]
end
%    \end{macrocode}
% \subsubsection{cloze}
%    \begin{macrocode}
function cloze.basic(head)
  local n = {} -- node
  local b = {} -- boolean
  local l = {} -- length
  local t = {} -- temp

  for hlist in node.traverse_id(node.id('hlist'), head) do

    -- To make life easier: We add at the beginning of each line a strut.
    -- Now we can add rule, color etc. nodes AFTER
    -- the first node of a line not BEFORE. AFTER is much more easier.
    n.head = hlist.head
    n.strut = node.insert_before(n.head, n.head, create.kern(0))
    hlist.head = n.head.prev

    if b.line_end then
      b.init_cloze = true
    end

    n.current = hlist.head

    while n.current do

      if check.marker(n.current, 'basic', 'start') or b.init_cloze then

        n.marker = registry.get_marker(n.current, 'basic', 'start')

        node.insert_after(hlist.head, n.current, create.color('text'))

        b.init_cloze = false

        n.stop = n.current
        while n.stop.next do

          b.line_end = true

          if check.marker(n.stop, 'basic', 'stop') then
            b.line_end = false
            break
          end

          n.stop = n.stop.next
        end

        l.line_width = node.dimensions(hlist.glue_set, hlist.glue_sign, hlist.glue_order, n.current, n.stop.next)

        head, n.line = insert.rule_colored(head, n.current, l.line_width)

        if registry.show_text then
          node.insert_after(head, n.line, create.kern(-l.line_width))
          node.insert_after(head, n.stop, create.color('reset'))
        else
          n.line.next = n.stop.next
          n.stop.prev = n.line.prev
        end

        n.current = n.stop.next
      else
        n.current = n.current.next
      end -- if

    end -- while

  end -- for

  return head
end -- function
%    \end{macrocode}
% Make cloze for macro clozefix
%
% Node list (show text)
%
% \begin{enumerate}
% \item W[n.start]
% \item R[n.line]
% \item K[n.kern\_start]
% \item W[textcolor]
% \item W[colorreset]
% \item K[n.kern\_stop]
% \item W[n.stop]
% \end{enumerate}
%
% Node list (hide text)
%
% \begin{enumerate}
% \item W[n.start]
% \item W[linecolor]
% \item R[length]
% \item W[colorreset]
% \item K[kern\_start]
% \item W[textcolor]
% \end{enumerate}
%
%    \begin{macrocode}
function cloze.fix_make(head, start, stop)
  local l = {} -- length

  l.width = tex.sp(registry.width)

  local n = {} -- node
  n.start = start
  n.stop = stop

  l.text_width = node.dimensions(n.start, n.stop)

  if registry.align == 'right' then
    l.kern_start = -l.text_width
    l.kern_stop = 0
  elseif registry.align == 'center' then
    l.half = (l.width - l.text_width) / 2
    l.kern_start = -l.half - l.text_width
    l.kern_stop = l.half
  else
    l.kern_start = -l.width
    l.kern_stop = l.width - l.text_width
  end

  head, n.line = insert.rule_colored(head, n.start, l.width)

  if registry.show_text then
    head, n.kern_start = node.insert_after(head, n.line, create.kern(l.kern_start))
    node.insert_after(head, n.kern_start, create.color('text'))
    node.insert_before(head, n.stop, create.whatsit_colorstack())
    node.insert_before(head, n.stop, create.kern(l.kern_stop))
  else
    n.line.next = n.stop.next
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function cloze.fix(head)
  local n = {} -- node

  n.start, n.stop = false
  for current in node.traverse_id(node.id('whatsit'), head) do

    if not n.start then n.start = registry.get_marker(current, 'fix', 'start') end
    if not n.stop then n.stop = registry.get_marker(current, 'fix', 'stop') end

    if n.start and n.stop then
      cloze.fix_make(head, n.start, n.stop)
      n.start, n.stop = false
    end
  end

  return head
end
%    \end{macrocode}
% Call for environment clozpar
%    \begin{macrocode}
function cloze.par(head)
  local l = {} -- length
  local n = {} -- node

  for hlist in node.traverse_id(node.id('hlist'), head) do

    for whatsit in node.traverse_id(node.id('whatsit'), hlist.head) do
      registry.get_marker(whatsit, 'par', 'start')
    end

    l.width = hlist.width

    n.head = hlist.head
    n.strut = node.insert_before(n.head, n.head, create.kern(0))
    hlist.head = n.head.prev

    head, n.rule = insert.rule_colored(head, n.strut, l.width)

    if registry.show_text then
      head, n.kern = node.insert_after(head, n.rule, create.kern(-l.width))
      node.insert_after(head, n.kern, create.color('text'))

      n.tail = node.tail(n.head)
      node.insert_after(n.head, n.tail, create.color('reset'))
    else
      n.rule.next = nil
    end
  end

  return head
end
%    \end{macrocode}
%
% \subsubsection{base}
%
% Base functions which are accessible in the sty file.
%
%    \begin{macrocode}
function base.register(mode)
  if mode == 'par' then
    luatexbase.add_to_callback('post_linebreak_filter', cloze.par, mode, 1)
    return true
  end

  if not is_registered[mode] then
    if mode == 'basic' then
      luatexbase.add_to_callback('post_linebreak_filter', cloze.basic, mode, 1)
    elseif mode == 'fix' then
      luatexbase.add_to_callback('pre_linebreak_filter', cloze.fix, mode, 1)
    else
      return false
    end
    is_registered[mode] = true
  end
end
%    \end{macrocode}
% Register the callbacks.
%    \begin{macrocode}
function base.unregister(mode)
  if mode == 'basic' then
    luatexbase.remove_from_callback('post_linebreak_filter', mode)
  elseif mode == 'fix' then
    luatexbase.remove_from_callback('pre_linebreak_filter', mode)
  else
    luatexbase.remove_from_callback('post_linebreak_filter', mode)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.set_global_options(options)
  options.show_text = base.show_text
  registry.global_options = options
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.marker(mode, position)
  local index = registry.set(mode, position)
  local marker = create.marker(index)
  node.write(marker)
end
%    \end{macrocode}
% Publish some functions to sty file.
%    \begin{macrocode}
base.hfill = insert.hfill
base.margin = insert.margin
base.set_option = registry.set_option
base.set_is_global = registry.set_is_global
base.unset_local_options = registry.unset_local_options
base.process_options = registry.process_options
base.get_defaults = registry.get_defaults
%    \end{macrocode}
%
%    \begin{macrocode}
return base
%    \end{macrocode}
% \iffalse
%</lua>
% \fi
%
% \Finale
\endinput
