% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the % conditions of
% the LaTeX Project Public License, either version 1.3 % of this license
% or (at your option) any later version. % The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrih.
%
% This work consists of the files cloze.dtx and cloze.ins
% and the derived filebase cloze.sty.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{cloze.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{cloze}
%<*package>
    [2015/06/16 v0.1 Package to typeset cloze worksheets or cloze tests]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage{cloze}
\usepackage{paralist}

\setlength{\fboxrule}{0.2pt}
\setlength{\fboxsep}{8pt}

\makeatletter
\newcommand{\@minipagerestore}{\setlength{\parindent}{10pt}}
\makeatother

\newsavebox{\examplebox}
\newenvironment{example}{%
  \medskip%
  \begin{lrbox}{\examplebox}%
  \begin{minipage}{0.9\linewidth}%
}{%
  \end{minipage}%
  \end{lrbox}%
  \noindent%
  \hspace{0.03\linewidth}%
  \fbox{\usebox{\examplebox}}%
  \medskip%
}

\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{cloze.dtx}
  \PrintChanges
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# Description

EN: `cloze` is a LaTeX package to generate cloze. It uses the
capabilities of the modern TeX engine LuaTex.

DE: `cloze` ist a LaTeX-Paket zum Erstellen von Lückentexten. Es
nutzt die Möglichkeiten der modernen TeX-Engine LuaTeX.

# Repository

https://github.com/Josef-Friedrich/cloze
%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{cloze.dtx}
% \title{The \cloze{cloze} package}
% \author{Josef Friedrich \\ \url{josef@friedrich.rocks}}
% \date{\fileversion~from \filedate}
%
% \maketitle
%
% \setcounter{secnumdepth}{5}
% \setcounter{tocdepth}{5}
% \tableofcontents
%
% \section{Introduction}
%
% \emph{cloze} is a \LaTeX{} package to generate cloze tests. It uses
% the capabilities of the modern \TeX{} engine \emph{Lua\TeX}. Therefor
% you must use Lua\LaTeX{} to produce documents containing clozes.
%
% \section{Usage}
%
% Put text here.
%
% \DescribeMacro{\setcloze} sdsdfsdf sdf sdf sdf sdf sdf sdf sdf
%
% \subsection{Command \cmd{\cloze}}
% \DescribeMacro{\cloze}
%
% \begin{example}
% Lorem ipsum \cloze{dolor} sit amet, \cloze{consectetur} adipisicing
% elit, sed do eiusmod tempor incididunt ut labore et dolore
% \cloze{magna aliqua. Ut enim ad minim veniam, quis nostrud
% exercitation ullamco laboris nisi} ut aliquip ex ea commodo consequat.
% \end{example}
%
%
% \subsection{Command \cmd{\clozefix}}
% \DescribeMacro{\clozefix}
%
% \begin{example}
% \noindent Lorem ipsum dolor sit amet:
% \begin{compactenum}
% \item \clozefix[width=5cm]{consectetur}
% \item \clozefix[width=5cm]{adipisicing}
% \item \clozefix[width=5cm]{elit}
% \end{compactenum}
% sed do eiusmod.
% \end{example}
%
%
% \subsection{Command \cmd{\clozefil}}
% \DescribeMacro{\clozefil}
%
% \begin{example}
% Lorem ipsum dolor sit amet, \clozefil{consectetur adipisicing elit, sed
% do eiusmod.}
%
% Ut enim \clozefil{ad minim veniam} exercitation.
% \end{example}
%
%
% \subsection{Environment \texttt{clozepar}}
% \DescribeEnv{clozepar}
%
% \begin{example}
% Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
% eiusmod tempor incididunt ut labore et dolore magna aliqua.
%
% \begin{clozepar}
% Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris
% nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in
% reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
% pariatur.
% \end{clozepar}
%
% Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
% officia deserunt mollit anim id est laborum.
% \end{example}
%
%
%
% \DescribeMacro{\clozefont}
%
% \DescribeMacro{\clozelinefil}
%
%
% \section{Options}
%
%
% \subsection{Option 'align'}
%
% Only the macro \cmd{\clozefix} takes the option \texttt{align} into
% account. Possible values are \texttt{left}, \texttt{center} and
% \texttt{right}. This option only makes sense, if the width of the
% cloze line is larger than the width of the cloze text.
%
% \begin{example}
% \noindent\clozefix[align=left,width=6cm]{Lorem ipsum}
% (\texttt{align=left})
%
% \noindent\clozefix[align=center,width=6cm]{Lorem ipsum}
% (\texttt{align=center})
%
% \noindent\clozefix[align=right,width=6cm]{Lorem ipsum}
% (\texttt{align=right})
% \end{example}
%
%
% \subsection{Options 'hide' and 'show'}
%
% The cloze text is displayed by default. Use the option \texttt{hide}
% to remove the cloze text from the output.  If you accidentally specify
% both options, the option \texttt{hide} is "stronger".
%
% \begin{example}
% \noindent\cmd{\cloze[hide]}\marg{dolor}:
% Lorem ipsum \cloze[hide]{dolor} sit amet. \\
% \noindent\cmd{\cloze[show]}\marg{dolor}:
% Lorem ipsum \cloze[show]{dolor} sit amet.
% \end{example}
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% \subsection{latex file}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{cloze}
\RequirePackage{luatexbase-mcb}
\RequirePackage{xcolor}
\RequirePackage{kvoptions}
\directlua{
  cloze = require("cloze")
}
%    \end{macrocode}
%
%
% \subsubsection{Internal macros}
%
%
% \begin{macro}{\cloze@set@to@global}
%    \begin{macrocode}
\def\cloze@set@to@global{%
 \directlua{cloze.set_is_global(true)}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@to@local}
%    \begin{macrocode}
\def\cloze@set@to@local{%
  \directlua{
  cloze.unset_local_options()
  cloze.set_is_global(false)
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@option}
%    \begin{macrocode}
\def\cloze@set@option[#1]#2{%
  \directlua{cloze.set_option('#1', '#2')}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@color}
%    \begin{macrocode}
\def\cloze@color#1{\csname\string\color@#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@local@options}
%    \begin{macrocode}
\def\cloze@set@local@options#1{%
  \cloze@set@to@local%
  \kvsetkeys{LC}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@start@marker}
%    \begin{macrocode}
\def\cloze@start@marker#1{%
  \strut\directlua{
    cloze.register('#1')
    cloze.marker('#1', 'start')
    cloze.process_options()
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@stop@marker}
%    \begin{macrocode}
\def\cloze@stop@marker#1{%
  \strut\directlua{
    cloze.marker('#1', 'stop')
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@margin}
%    \begin{macrocode}
\def\cloze@margin#1{%
  \directlua{cloze.margin()}%
  #1%
  \directlua{cloze.margin()}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Options}
%
%    \begin{macrocode}
\cloze@set@to@global
%    \end{macrocode}
% LC = cloze
%    \begin{macrocode}
\SetupKeyvalOptions{
  family=LC,
  prefix=LC@
}
%    \end{macrocode}
%
%
% \paragraph{Option 'align'}
%
%    \begin{macrocode}
\DeclareStringOption{align} % Affects only \clozefix
\define@key{LC}{align}[]{\cloze@set@option[align]{#1}}
%    \end{macrocode}
%
%
% \paragraph{Option 'distance'}
%
%    \begin{macrocode}
\DeclareStringOption{distance}
\define@key{LC}{distance}[]{\cloze@set@option[distance]{#1}}
%    \end{macrocode}
%
%
% \paragraph{Option 'hide'}
%
%    \begin{macrocode}
\DeclareVoidOption{hide}{\cloze@set@option[hide]{true}}
%    \end{macrocode}
%
%
% \paragraph{Option 'linecolor'}
%
%    \begin{macrocode}
\DeclareStringOption{linecolor}
\define@key{LC}{linecolor}[]{\cloze@set@option[linecolor]{\cloze@color{#1}}}
%    \end{macrocode}
%
%
% \paragraph{Option 'margin'}
%
%    \begin{macrocode}
\DeclareStringOption{margin}
\define@key{LC}{margin}[]{\cloze@set@option[margin]{#1}}
%    \end{macrocode}
%
%
% \paragraph{Option 'show'}
%
%    \begin{macrocode}
\DeclareVoidOption{show}{\cloze@set@option[show]{true}}
%    \end{macrocode}
%
%
% \paragraph{Option 'textcolor'}
%
%    \begin{macrocode}
\DeclareStringOption{textcolor}
\define@key{LC}{textcolor}[]{\cloze@set@option[textcolor]{\cloze@color{#1}}}
%    \end{macrocode}
%
%
% \paragraph{Option 'thickness'}
%
%    \begin{macrocode}
\DeclareStringOption{thickness}
\define@key{LC}{thickness}[]{\cloze@set@option[thickness]{#1}}
%    \end{macrocode}
%
%
% \paragraph{Option 'width'}
%    \begin{macrocode}
\DeclareStringOption{width} % Affects only \clozefix
\define@key{LC}{width}[]{\cloze@set@option[width]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyvalOptions{LC}
%    \end{macrocode}
%
% \subsubsection{Public macros}
%
% \begin{macro}{\setcloze}
%    \begin{macrocode}
\newcommand{\setcloze}[1]{%
  \cloze@set@to@global%
  \kvsetkeys{LC}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozefont}
%    \begin{macrocode}
\newcommand{\clozefont}{\itshape}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze}
%    \begin{macrocode}
\newcommand{\cloze}[2][]{%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{basic}%
  {%
    \clozefont%
    \cloze@margin{#2}%
  }%
  \cloze@stop@marker{basic}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozefix}
% Creates a cloze on one line with a fixed length.
%    \begin{macrocode}
\newcommand{\clozefix}[2][]{%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{fix}%
  {%
    \clozefont%
    \cloze@margin{#2}%
  }%
  \cloze@stop@marker{fix}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{environment}{clozepar}
%    \begin{macrocode}
\newenvironment{clozepar}[1][]%
{%
  \par%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{par}%
  \clozefont%
}%
{%
  \cloze@stop@marker{par}%
  \par%
  \directlua{cloze.unregister('par')}%
}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{macro}{\clozefil}
%    \begin{macrocode}
\newcommand{\clozefil}[2][]{%
  \cloze[#1]{#2}\clozelinefil[#1]%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozelinefil}
% Creates a cloze on one line with a fixed length.
%    \begin{macrocode}
\newcommand{\clozelinefil}[1][]{%
  \cloze@set@local@options{#1}%
  \strut
  \directlua{cloze.hfill()}%
  \strut
}
%    \end{macrocode}
% \end{macro}
%
%
% \iffalse
%</package>
%<*lua>
% \fi
% \subsection{lua file}
%    \begin{macrocode}
local check = {}
check.user_id = 3121978

local get = {}
local create = {}
local insert = {}

local registry = {}
registry.storage = {}
registry.defaults = {
  ['align'] = 'l',
  ['distance'] = '3pt',
  ['linecolor'] = '0 0 0 rg 0 0 0 RG', -- black
  ['margin'] = '3pt',
  ['resetcolor'] = '0 0 0 rg 0 0 0 RG', -- black
  ['show_text'] = true,
  ['textcolor'] = '0 0 1 rg 0 0 1 RG', -- blue
  ['thickness'] = '0.4pt',
  ['width'] = '2cm',
}
registry.global_options = {}
registry.local_options = {}
registry.options = {}

local cloze = {}
local base = {}
local is_registered = {}

local options
%    \end{macrocode}
% \subsubsection{Check functions}
%    \begin{macrocode}
function check.whatsit_marker(item)
  if item.id == node.id('whatsit')
      and item.subtype == 44
      and item.user_id == check.user_id then
    return true
  else
    return false
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function check.marker(item, mode, position)
  local data = registry.marker_data(item)

  if data and data.mode == mode and data.position == position then
    return true
  else
    return false
  end
end
%    \end{macrocode}
% \subsubsection{Create functions}
%    \begin{macrocode}
function create.whatsit_colorstack(data)
  if not data then
    -- black
    data = '0 0 0 rg 0 0 0 RG'
  end

  local node = node.new('whatsit', 'pdf_colorstack')
  node.stack = 0
  node.data = data

  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.color(option)
  local data

  if option == 'line' then
    data = registry.linecolor
  elseif option == 'text' then
    data = registry.textcolor
  elseif option == 'reset' then
    data = nil
  else
    data = nil
  end

  return create.whatsit_colorstack(data)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.rule(width)
  local node = node.new(node.id('rule'))
  local height = tex.sp(registry.thickness) - tex.sp(registry.distance)

  node.depth = tex.sp(registry.distance)
  node.height = height
  node.width = width

  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.kern(kern)
  local node = node.new(node.id('kern'))
  node.kern = kern
  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.glyph()
  local node = node.new(node.id('glyph'))
  node.char = 34
  return node
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.marker(index)
  local marker = node.new('whatsit','user_defined')
  marker.type = 100 -- number
  marker.user_id = check.user_id
  marker.value = index

  return marker
end
%    \end{macrocode}
%
%    \begin{macrocode}
function create.hfill()
  local glue = node.new('glue')
  glue.subtype = 100

  local glue_spec = node.new('glue_spec')
  glue_spec.stretch = 65536
  glue_spec.stretch_order = 3

  glue.spec = glue_spec

  local rule = create.rule(0)
  rule.dir = 'TLT'

  glue.leader = rule

  return glue
end
%    \end{macrocode}
%
% \subsubsection{Insert functions}
%
%    \begin{macrocode}
function insert.hfill()
  registry.process_options()
  node.write(create.color('line'))
  node.write(create.hfill())
  node.write(create.color('reset'))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function insert.margin()
  local kern = create.kern(tex.sp(registry.margin))
  node.write(kern)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function insert.rule_colored(head, current, width)
  -- Append rule and kern to the node list.
  local rule = create.rule(width)

  head, new = node.insert_after(head, current, create.color('line'))
  head, new = node.insert_after(head, new, rule)
  head, new = node.insert_after(head, new, create.color('reset'))

  return head, new
end
%    \end{macrocode}
%
% \subsubsection{registry}
%
% Functions to deal with option handling and storing them in a lua
% table.
%
%    \begin{macrocode}
function registry.get_index()
  if not registry.index then
    registry.index = 0
  end

  registry.index = registry.index + 1
  return registry.index
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_option(key, value)
  if value == '' or value == '\\color@ ' then
    return false
  end

  if registry.is_global == true then
    registry.global_options[key] = value
  else
    registry.local_options[key] = value
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_is_global(value)
  registry.is_global = value
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.unset_local_options()
  registry.local_options = {}
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set(mode, position)
  local index = registry.get_index()

  local data = {
    ['mode'] = mode,
    ['position'] = position
  }

  if registry.local_options then
    local cleaned_values = {}
    for key, value in pairs(registry.local_options) do
      if value ~= '' then
        cleaned_values[key] = value
      end
    end
    data.values = cleaned_values
  end

  registry.storage[index] = data
  return index
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get(index)
  return registry.storage[index]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_show_text(options)
  if not options then
    return nil
  end

  if options.hide == true or options.hide == 'true'  then
    return false
  elseif options.show == true or options.show == 'true'  then
    return true
  else
    return nil
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
-- Unset options which have the values 'unset' or '\color@ '
function registry.merge_local_options()
  if registry.local_options then
    registry.options = registry.local_options
  else
    registry.options = {}
  end
  registry.options.show_text = registry.set_show_text(registry.local_options)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.merge_global_options()
  registry.global_options.show_text = registry.set_show_text(registry.global_options)

  for key, value in pairs(registry.global_options) do
    if registry.options[key] == nil or registry.options[key] == '' then
      registry.options[key] = value
    end
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.merge_defaults()
  for key, value in pairs(registry.defaults) do
    if registry.options[key] == nil or registry.options[key] == '' then
      registry.options[key] = value
    end
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.fix_align_options()
  local align = string.lower(registry.options.align)
  local result

  if align == 'r' then
    result = 'right'
  elseif align == 'c' then
    result = 'center'
  elseif align == 'l' then
    result = 'left'
  else
    result = align
  end

  registry.options.align = align
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.move_to_base()
  for key, value in pairs(registry.options) do
    registry[key] = value
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.debug(table, identifier)
  for key, value in pairs(table) do
    print(identifier .. ' KEY: ' .. tostring(key) .. ' VALUE: ' .. tostring(value))
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.process_options()
  registry.merge_local_options()
  registry.merge_global_options()
  registry.merge_defaults()
  registry.fix_align_options()
  registry.move_to_base()
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.marker_data(item)
  if not check.whatsit_marker(item) then
    return false
  else
    return registry.get(item.value)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.marker_values(item)
  local data = registry.marker_data(item)
  registry.local_options = data.values
  return data.values
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_marker(item, mode, position)
  local out

  if check.marker(item, mode, position) then
    registry.marker = item
    out = item
  else
    out = false
  end

  if out and position == 'start' then
    registry.marker_values(item)
    registry.process_options()
  end

  return out
end
%    \end{macrocode}
% \subsubsection{cloze}
%    \begin{macrocode}
function cloze.basic(head)
  local n = {} -- node
  local b = {} -- boolean
  local l = {} -- length
  local t = {} -- temp

  for hlist in node.traverse_id(node.id('hlist'), head) do

    -- To make life easier: We add at the beginning of each line a strut.
    -- Now we can add rule, color etc. nodes AFTER
    -- the first node of a line not BEFORE. AFTER is much more easier.
    n.head = hlist.head
    n.strut = node.insert_before(n.head, n.head, create.kern(0))
    hlist.head = n.head.prev

    if b.line_end then
      b.init_cloze = true
    end

    n.current = hlist.head

    while n.current do

      if check.marker(n.current, 'basic', 'start') or b.init_cloze then

        n.marker = registry.get_marker(n.current, 'basic', 'start')

        node.insert_after(hlist.head, n.current, create.color('text'))

        b.init_cloze = false

        n.stop = n.current
        while n.stop.next do

          b.line_end = true

          if check.marker(n.stop, 'basic', 'stop') then
            b.line_end = false
            break
          end

          n.stop = n.stop.next
        end

        l.line_width = node.dimensions(hlist.glue_set, hlist.glue_sign, hlist.glue_order, n.current, n.stop.next)

        head, n.line = insert.rule_colored(head, n.current, l.line_width)

        if registry.show_text then
          node.insert_after(head, n.line, create.kern(-l.line_width))
          node.insert_after(head, n.stop, create.color('reset'))
        else
          n.line.next = n.stop.next
          n.stop.prev = n.line.prev
        end

        n.current = n.stop.next
      else
        n.current = n.current.next
      end -- if

    end -- while

  end -- for

  return head
end -- function
%    \end{macrocode}
% Make cloze for macro clozefix
%
% Node list (show text)
%
% \begin{enumerate}
% \item W[n.start]
% \item R[n.line]
% \item K[n.kern\_start]
% \item W[textcolor]
% \item W[colorreset]
% \item K[n.kern\_stop]
% \item W[n.stop]
% \end{enumerate}
%
% Node list (hide text)
%
% \begin{enumerate}
% \item W[n.start]
% \item W[linecolor]
% \item R[length]
% \item W[colorreset]
% \item K[kern\_start]
% \item W[textcolor]
% \end{enumerate}
%
%    \begin{macrocode}
function cloze.fix_make(head, start, stop)
  local l = {} -- length

  l.width = tex.sp(registry.width)

  local n = {} -- node
  n.start = start
  n.stop = stop

  l.text_width = node.dimensions(n.start, n.stop)

  if registry.align == 'right' then
    l.kern_start = -l.text_width
    l.kern_stop = 0
  elseif registry.align == 'center' then
    l.half = (l.width - l.text_width) / 2
    l.kern_start = -l.half - l.text_width
    l.kern_stop = l.half
  else
    l.kern_start = -l.width
    l.kern_stop = l.width - l.text_width
  end

  head, n.line = insert.rule_colored(head, n.start, l.width)

  if registry.show_text then
    head, n.kern_start = node.insert_after(head, n.line, create.kern(l.kern_start))
    node.insert_after(head, n.kern_start, create.color('text'))
    node.insert_before(head, n.stop, create.whatsit_colorstack())
    node.insert_before(head, n.stop, create.kern(l.kern_stop))
  else
    n.line.next = n.stop.next
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function cloze.fix(head)
  local n = {} -- node

  n.start, n.stop = false
  for current in node.traverse_id(node.id('whatsit'), head) do

    if not n.start then n.start = registry.get_marker(current, 'fix', 'start') end
    if not n.stop then n.stop = registry.get_marker(current, 'fix', 'stop') end

    if n.start and n.stop then
      cloze.fix_make(head, n.start, n.stop)
      n.start, n.stop = false
    end
  end

  return head
end
%    \end{macrocode}
% Call for environment clozpar
%    \begin{macrocode}
function cloze.par(head)
  local l = {} -- length
  local n = {} -- node

  for hlist in node.traverse_id(node.id('hlist'), head) do

    for whatsit in node.traverse_id(node.id('whatsit'), hlist.head) do
      registry.get_marker(whatsit, 'par', 'start')
    end

    l.width = hlist.width

    n.head = hlist.head
    n.strut = node.insert_before(n.head, n.head, create.kern(0))
    hlist.head = n.head.prev

    head, n.rule = insert.rule_colored(head, n.strut, l.width)

    if registry.show_text then
      head, n.kern = node.insert_after(head, n.rule, create.kern(-l.width))
      node.insert_after(head, n.kern, create.color('text'))

      n.tail = node.tail(n.head)
      node.insert_after(n.head, n.tail, create.color('reset'))
    else
      n.rule.next = nil
    end
  end

  return head
end
%    \end{macrocode}
%
% \subsubsection{base}
%
% Base functions which are accessible in the sty file.
%
%    \begin{macrocode}
function base.register(mode)
  if mode == 'par' then
    luatexbase.add_to_callback('post_linebreak_filter', cloze.par, mode, 1)
    return true
  end

  if not is_registered[mode] then
    if mode == 'basic' then
      luatexbase.add_to_callback('post_linebreak_filter', cloze.basic, mode, 1)
    elseif mode == 'fix' then
      luatexbase.add_to_callback('pre_linebreak_filter', cloze.fix, mode, 1)
    else
      return false
    end
    is_registered[mode] = true
  end
end
%    \end{macrocode}
% Register the callbacks.
%    \begin{macrocode}
function base.unregister(mode)
  if mode == 'basic' then
    luatexbase.remove_from_callback('post_linebreak_filter', mode)
  elseif mode == 'fix' then
    luatexbase.remove_from_callback('pre_linebreak_filter', mode)
  else
    luatexbase.remove_from_callback('post_linebreak_filter', mode)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.set_global_options(options)
  options.show_text = base.show_text
  registry.global_options = options
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.marker(mode, position)
  local index = registry.set(mode, position)
  local marker = create.marker(index)
  node.write(marker)
end
%    \end{macrocode}
% Publish some functions to sty file.
%    \begin{macrocode}
base.hfill = insert.hfill
base.margin = insert.margin
base.set_option = registry.set_option
base.set_is_global = registry.set_is_global
base.unset_local_options = registry.unset_local_options
base.process_options = registry.process_options
%    \end{macrocode}
%
%    \begin{macrocode}
return base
%    \end{macrocode}
% \iffalse
%</lua>
% \fi
%
% \Finale
\endinput
