% \iffalse meta-comment
%
% Copyright (C) 2015 by Josef Friedrich <josef@friedrich.rocks>
% ----------------------------------------------------------------------
% This work may be distributed and/or modified under the % conditions of
% the LaTeX Project Public License, either version 1.3 % of this license
% or (at your option) any later version. % The latest version of this
% license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Josef Friedrih.
%
% This work consists of the files cloze.dtx and cloze.ins
% and the derived filebase cloze.sty.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{cloze.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{cloze}
%<*package>
    [2015/06/16 v0.1 Package to typeset cloze worksheets or cloze tests]
%</package>
%<*driver>
\documentclass[draft]{ltxdoc}
\usepackage[show]{cloze}
\usepackage{paralist}
\usepackage[
  colorlinks=true,
  linkcolor=red,
  filecolor=red,
  urlcolor=red,
]{hyperref}

\MakeShortVerb{\|}

\setlength{\fboxrule}{0.2pt}
\setlength{\fboxsep}{4pt}

\makeatletter
\newcommand{\@minipagerestore}{\setlength{\parindent}{10pt}}
\makeatother

\newsavebox{\examplebox}
\newenvironment{clozeexample}{%
  \noindent%
  \begin{lrbox}{\examplebox}%
  \begin{minipage}{0.9\textwidth}%
  \footnotesize%
}{%
  \end{minipage}%
  \end{lrbox}%
  \begin{center}%
    \fbox{\usebox{\examplebox}}%
  \end{center}%
}

\definecolor{grayline}{gray}{0.9}
\definecolor{graybackground}{gray}{0.97}

\newsavebox{\codebox}
\newenvironment{code}{%
  \noindent%
  \begin{lrbox}{\codebox}%
  \begin{minipage}{0.9\textwidth}%
}{%
  \end{minipage}%
  \end{lrbox}%
  \begin{center}%
    \fcolorbox{grayline}{graybackground}{\usebox{\codebox}}%
  \end{center}%
}

\newcommand{\tighten}{\vspace{-6pt}}

\newcommand{\getdefaults}[1]{%
  \directlua{tex.print(cloze.get_defaults('#1'))}%
}

\newcommand{\expdesc}[1]{(|#1|)}

\newcommand{\desc}[1]{%
  \hfill%
  \expdesc{#1}%
  \par%
}

\def\tt#1{\texttt{#1}}

\def\secref#1{(\rightarrow\ \ref{#1})}

\newcommand{\option}[2]{\tt{[#1=}\meta{#2}\tt{]}}

\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}

\providecommand*{\url}{\texttt}
\GetFileInfo{cloze.dtx}
\title{The \cloze{cloze} package\thanks{Robert-Michael Huber, Paul Isambert}}
\author{Josef Friedrich\\ \url{josef@friedrich.rocks}}
\date{\fileversion~from \filedate}

\maketitle

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\tableofcontents

%-----------------------------------------------------------------------
% Introduction
%-----------------------------------------------------------------------

\section{Introduction}

\emph{cloze} is a \LaTeX{} package to generate cloze texts. It uses
the capabilities of the modern \TeX{} engine \emph{Lua\TeX}. Therefore,
you must use Lua\LaTeX{} to create documents containing gaps.

The main feature of the package is that the formatting doesn't change
when using the |hide| and |show| \secref{sec:option-hide} options.

\newcommand{\clozelorem}{%
Lorem ipsum \cloze{dolor sit} amet, consectetur \cloze{adipisicing}
elit, sed do eiusmod tempor incididunt ut labore et \cloze{dolore magna}
aliqua. Ut enim ad minim veniam, quis nostrud \cloze{exercitation}
ullamco laboris nisi ut \cloze{aliquip} ex ea commodo consequat.%
}

\begin{clozeexample}
\clozelorem
\end{clozeexample}

\clozeset{hide}

The command |\clozeset{hide}| only shows gaps.
When you put both texts on top of each other you will see that they
perfectly match.

\begin{clozeexample}
\clozelorem
\end{clozeexample}

\clozeset{show}

%-----------------------------------------------------------------------
% Usage
%-----------------------------------------------------------------------

\section{Usage}

There are three commands and one environment to generate
cloze texts: \cmd{\cloze}, \cmd{\clozefix}, \cmd{\clozefil} and
|clozepar|.

%%
% \cloze
%%

\subsection{The commands and environments}

\subsubsection{\cmd{\cloze}}
\label{sec:command-cloze}

\DescribeMacro{\cloze} \cmd{\cloze}\oarg{options}\marg{some text}: The
command \cmd{\cloze} is similar to a command that offers the possibility
to underline the texts. \cmd{\cloze} does not prevent line breaks. The
width of a gap depends on the number of letters and the font used.
The only option which affects the widths of a gap is the option
|margin| \secref{sec:option-margin}.

\begin{clozeexample}
Lorem ipsum \cloze{dolor} sit amet, \cloze{consectetur} adipisicing
elit, sed do eiusmod tempor incididunt ut labore et dolore
\cloze{magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi} ut aliquip ex ea commodo consequat.
\end{clozeexample}

%%
% \clozesetfont
%%

\subsubsection{\cmd{\clozesetfont}}
\label{sec:command-setclozefont}

\DescribeMacro{\clozesetfont}
The gap font can be changed by using the command
\cmd{\clozesetfont}. \tt{\string\set\-cloze\-font} redefines the command
\cmd{\clozefont} which contains the font definition.
Thus, the command \tt{\string\clozesetfont\string{\string\Large\string}}
has the same effect as
\tt{\string\re\-new\-com\-mand\string{\string\cloze\-font\string}%
\string{\string\Large\string}}.

\clozesetfont{\Large}

\begin{clozeexample}
Excepteur \cloze{sint} occaecat \cloze{cupidatat} non proident.
\end{clozeexample}

\noindent Please do not put any color definitions in
\cmd{\clozesetfont}, as it won't work. Use the option
|textcolor| instead \secref{sec:option-textcolor}.

|\clozesetfont{\ttfamily\normalsize}| changes the gap text for example
into a normal sized typewriter font.

\clozesetfont{\ttfamily\normalsize}

\begin{clozeexample}
Excepteur \cloze{sint} occaecat \cloze{cupidatat} non proident.
\end{clozeexample}

\clozesetfont{\itshape}

%%
% \clozefix
%%

\subsubsection{\cmd{\clozefix}}
\label{sec:command-clozefix}

\DescribeMacro{\clozefix} \cmd{\clozefix}\oarg{options}\marg{some text}:
The command \cmd{\clozefix} creates gaps with a fixed width. The
clozes are default concering the width \tt{\getdefaults{width}}.

\begin{clozeexample}
\noindent Lorem ipsum dolor sit amet:
\begin{compactenum}
\item \clozefix[width=5cm]{consectetur}
\item \clozefix[width=5cm]{adipisicing}
\item \clozefix[width=5cm]{elit}
\end{compactenum}
sed do eiusmod.
\end{clozeexample}

%%
% \clozefil
%%

\subsubsection{\cmd{\clozefil}}
\label{sec:command-clozefil}

\DescribeMacro{\clozefil} \cmd{\clozefil}\oarg{options}\marg{some text}:
The name of the command is inspired by \cmd{\hfil}, \cmd{\hfill}, and
\cmd{\hfilll}. Only \cmd{\clozefil} fills out all available horizontal
spaces with a line.

\begin{clozeexample}
Lorem ipsum dolor sit amet, \clozefil{consectetur adipisicing elit, sed
do eiusmod.}

Ut enim \clozefil{ad minim veniam} exercitation.
\end{clozeexample}

%%
% clozepar
%%

\subsubsection{\tt{clozepar}}
\label{sec:command-clozepar}

\DescribeEnv{clozepar} |\begin{clozepar}|\oarg{options} \dots
\textit{some text} \dots |\end{clozepar}|: The environment \tt{clozepar}
transforms a complete paragraph into a cloze text. The options |align|,
|margin| and |width| have no effect on this environment.

\begin{clozeexample}
Lorem ipsum dolor sit amet, consectetur adipisicing elit ullamco laboris
nisi.

\begin{clozepar}
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi
ut aliquip ex ea commodo consequat. Duis aute irure dolor in
reprehenderit in voluptate velit esse cillum.
\end{clozepar}

Excepteur sint occaecat cupidatat non proident.
\end{clozeexample}

%%
% \clozeline
%%

\subsubsection{\cmd{\clozeline}}
\label{sec:command-clozeline}

\DescribeMacro{\clozeline}
\cmd{\clozeline}\oarg{options}:
To create a cloze line of a certain width, use the command
\cmd{\clozeline}. The default width of the line is
\tt{\getdefaults{width}}. In combination with the other cloze commands
you can create for example an irregular alignment of the cloze text.

\begin{code}
\begin{verbatim}
Ut enim ad
\clozeline[width=1cm]\cloze{minim}\clozeline[width=3cm]
minim veniam
\end{verbatim}
\end{code}

\tighten

\begin{clozeexample}
Ut enim ad \clozeline[width=1cm]\cloze{minim}\clozeline[width=3cm] minim
veniam,
\end{clozeexample}

%%
% \clozelinefil
%%

\subsubsection{\cmd{\clozelinefil}}

\DescribeMacro{\clozelinefil}
\cmd{\clozelinefil}\oarg{options}:
This command \cmd{\clozelinefil} fills the
complete available horizontal space with a line. Moreover,
\cmd{\clozelinefil} was used to create \cmd{\clozefil}.

\begin{clozeexample}
Lorem\clozelinefil
\end{clozeexample}

%-----------------------------------------------------------------------
% Options
%-----------------------------------------------------------------------

\subsection{The options}

%%
% Local and global options
%%

\subsubsection{Local and global options}

The \emph{cloze} package distinguishs between \emph{local} and
\emph{global} options. Besides the possiblity to set \emph{global}
options in the \cmd{\usepackage}\oarg{global options}\marg{cloze}
declaration, the cloze package offers a special command to set
\emph{global} options:
\cmd{\clozeset}\marg{global options}

%%
% \clozeset
%%

\subsubsection{\cmd{\clozeset}}

\DescribeMacro{\clozeset}
\cmd{\clozeset}\marg{global options}: The command can set \emph{global}
options for each paragraph.

\begin{code}
\begin{verbatim}
\clozeset{textcolor=red} Lorem \cloze{ipsum} dolor \par
\clozeset{textcolor=green} Lorem \cloze{ipsum} dolor
\end{verbatim}
\end{code}

\tighten

\begin{clozeexample}
\clozeset{textcolor=red} Lorem \cloze{ipsum} dolor \par
\clozeset{textcolor=green} Lorem \cloze{ipsum} dolor
\end{clozeexample}

\cmd{\clozeset} does not change the options within a paragraph. As you
can see in the example below the last \cmd{\clozeset} applies the color
green for both gaps.

\begin{code}
\begin{verbatim}
\clozeset{textcolor=red} Lorem \cloze{ipsum} dolor
\clozeset{textcolor=green} Lorem \cloze{ipsum} dolor
\end{verbatim}
\end{code}

\tighten

\begin{clozeexample}
\clozeset{textcolor=red} Lorem \cloze{ipsum} dolor
\clozeset{textcolor=green} Lorem \cloze{ipsum} dolor
\end{clozeexample}

\clozereset

%%
% \clozereset
%%

\subsubsection{\cmd{\clozereset}}

\DescribeMacro{\clozereset}
\cmd{\clozereset}: The command resets all \emph{global} options to the
default values. It has no effect on the \emph{local} options.

\begin{code}
\begin{verbatim}
\clozeset{
  thickness=3mm,
  linecolor=yellow,
  textcolor=magenta,
  margin=-2pt
}
\end{verbatim}
\end{code}

\tighten

\clozeset{thickness=3mm,linecolor=yellow,textcolor=magenta,margin=-2pt}

\begin{clozeexample}
Very \cloze{silly} global \cloze{options}.
\end{clozeexample}

\begin{code}
|\clozereset|
\end{code}
\clozereset

\tighten

\begin{clozeexample}
\cloze{Relax!} We can reset \cloze{those} options.
\end{clozeexample}

%%
% \clozereset
%%

\subsubsection{\cmd{\clozeshow} and \cmd{\clozehide}}

\DescribeMacro{\clozeshow} \DescribeMacro{\clozehide}
\cmd{\clozeshow} and \cmd{\clozehide}: This commands are shortcuts for
\cmd{\clozeset}\marg{show} and \cmd{\clozeset}\marg{hide}.

\begin{code}
|\clozehide|
\end{code}
\clozehide

\tighten

\begin{clozeexample}
Lorem \cloze{ipsum dolor sit} amet, consectetur \cloze{adipisicing}
elit.
\end{clozeexample}

\begin{code}
|\clozeshow|
\end{code}
\clozeshow

\tighten

\begin{clozeexample}
Lorem \cloze{ipsum dolor sit} amet, consectetur \cloze{adipisicing}
elit.
\end{clozeexample}

%%
% align
%%

\subsubsection{\tt{align}}
\label{sec:option-align}

\option{align}{left/center/right}:
Only the macro \cmd{\clozefix} \secref{sec:command-clozefix} takes the
option \tt{align} into account. Possible values are \tt{left},
\tt{center} and \tt{right}. This option only makes sense, if the width
of the line is larger than the width of the text.

\newcommand{\optionsalign}[1]{%
  \noindent%
  \clozefix[align=#1,width=8cm]{Lorem ipsum}%
  \desc{#1}%
}

\begin{clozeexample}
\optionsalign{left}
\optionsalign{center}
\optionsalign{right}
\end{clozeexample}

%%
% distance
%%

\subsubsection{\tt{distance}}
\label{sec:option-distance}

\option{distance}{dimen}:
The option |distance| specifies the spacing between the baseline of the
text and the gap line. The larger the dimension of the option
|distance|, the more moves the line down. Negative values cause the line
to appear above the baseline. The default value is
\tt{\getdefaults{distance}}.

\newcommand{\optiondistance}[1]{%
  \noindent%
  \clozefil[distance=#1]{Lorem ipsum dolor sit amet.}
  \expdesc{#1}
  \par%
}

\begin{clozeexample}
\optiondistance{\getdefaults{distance}}
\optiondistance{3pt}
\optiondistance{-3pt}
\end{clozeexample}

%%
% hide and show
%%

\subsubsection{\tt{hide} and \tt{show}}
\label{sec:option-hide}
\label{sec:option-show}

\tt{[hide]} and \tt{[show]}:
By default the cloze text is displayed. Use the option |hide| to remove
the cloze text from the output.  If you accidentally specify both
options -- |hide| and |show| -- the last option "wins".

\newcommand{\optionshow}[1]{%
  \noindent%
  Lorem ipsum \cloze[#1]{dolor sit amet}, consectetur
  \cloze[#1]{adipisicing} elit.%
  \desc{#1}%
}

\begin{clozeexample}
\optionshow{hide}
\optionshow{show}
\optionshow{show,hide}
\optionshow{hide,show}
\end{clozeexample}

%%
% linecolor and textcolor
%%

\subsubsection{\tt{linecolor} and \tt{textcolor}}
\label{sec:option-linecolor}
\label{sec:option-textcolor}

\option{linecolor}{color name} and
\option{textcolor}{color name}:
Values for both color options are color names used by the xcolor
package. To define your own color use the following command:

|\definecolor{myclozecolor}{rgb}{0.1,0.4,0.6}|
\definecolor{myclozecolor}{rgb}{0.1,0.4,0.6}

\newcommand{\optioncolor}[2]{%
  \noindent%
  \clozefil[#1=#2]{Lorem ipsum dolor sit amet, consectetur} %
  \expdesc{#2}%
  \par%
}

\begin{clozeexample}
\optioncolor{textcolor}{myclozecolor}
\optioncolor{textcolor}{red}
\optioncolor{textcolor}{green}
\end{clozeexample}

You can use the same color names to colorize the cloze lines.

\begin{clozeexample}
\optioncolor{linecolor}{myclozecolor}
\optioncolor{linecolor}{red}
\optioncolor{linecolor}{green}
\end{clozeexample}

%%
% margin
%%

\subsubsection{\tt{margin}}
\label{sec:option-margin}

\option{margin}{dimen}:
The option |margin| indicates how far the line sticks up from the text.
The option can be used with the commands \cmd{\cloze}, \cmd{\clozefix}
and \cmd{\clozefil}. The default value of the option is
\tt{\getdefaults{margin}}.

\newcommand{\optionmargin}[1]{%
  \noindent%
  Lorem ipsum \cloze[margin=#1]{dolor} sit amet.%
  \desc{#1}%
}

\begin{clozeexample}
\optionmargin{0pt}
\optionmargin{5mm}
\optionmargin{1cm}
\optionmargin{6em}
\optionmargin{-4pt}
\end{clozeexample}

% Folgt ein Satzzeichen direkt auf eine Lücke, so findet der
% Zeilenumbruch erst nach dem Satzzeichen statt. Auch ein noch so großer
% Wert für |margin| beeinflusst dieses Verhalten nicht.
Is a punctation mark placed directly after a gap, then the line breaks
after this punctation mark. Even the most large value of |margin| does
not affect this behavior.

\begin{clozeexample}
\clozeset{margin=3mm}
\cloze{Lorem}, \cloze{ipsum}. \cloze{dolor}; \cloze{sit}: \cloze{amet},
\cloze{consectetur}. \cloze{adipisicing}; \cloze{elit}: \cloze{sed},
\cloze{do}. \cloze{eiusmod}; \cloze{tempor}.
\end{clozeexample}

\clozereset

%%
% thickness
%%

\subsubsection{\tt{thickness}}
\label{sec:option-thickness}

\option{thickness}{dimen}:
The option |thickness| indicates how thick the line is. The option
|distance| \secref{sec:option-distance} is not affected by this option,
because the bottom of the line moves down. The default value of this
option is \tt{\getdefaults{thickness}}.

\newcommand{\optionthickness}[1]{%
  \noindent%
  Lorem \cloze[thickness=#1]{ipsum dolor sit} amet.%
  \desc{#1}%
}

\begin{clozeexample}
\optionthickness{0.01pt}
\optionthickness{1pt}
\optionthickness{2pt}
\end{clozeexample}

%%
% width
%%

\subsubsection{\tt{width}}\label{sec:option-width}

\option{width}{dimen}:
The only command which can be changed by the option |width| is
\cmd{\clozefix} \secref{sec:command-clozefix}. The default value of the
option is \tt{\getdefaults{width}}.

\newcommand{\optionwidth}[1]{%
  \noindent%
  Lorem \clozefix[width=#1]{dolor} amet.%
  \desc{#1}%
}

\begin{clozeexample}
\optionwidth{3cm}
\optionwidth{5cm}
\optionwidth{7cm}
\end{clozeexample}

  \DocInput{cloze.dtx}
  \PrintChanges
  \PrintIndex
\end{document}
%</driver>
%<*readme>
# Description

EN: `cloze` is a LaTeX package to generate cloze. It uses the
capabilities of the modern TeX engine LuaTex.

DE: `cloze` ist a LaTeX-Paket zum Erstellen von Lückentexten. Es nutzt
die Möglichkeiten der modernen TeX-Engine LuaTeX.

# Repository

https://github.com/Josef-Friedrich/cloze

# Installation

Get source:

    git clone git@github.com:Josef-Friedrich/cloze.git
    cd cloze

Compile:

    make

or manually:

    luatex cloze.ins
    lualatex cloze.dtx
    makeindex -s gglo.ist -o cloze.gls cloze.glo
    makeindex -s gind.ist -o cloze.ind cloze.idx
    lualatex cloze.dtx

%</readme>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/06/16}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\directlua}
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
% \subsection{The file \tt{cloze.sty}}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{cloze}
\RequirePackage{luatexbase-mcb,fontspec,xcolor,kvoptions}
\directlua{
  cloze = require("cloze")
}
%    \end{macrocode}
%
%
% \subsubsection{Internal macros}
%
%
% \begin{macro}{\cloze@set@to@global}
%    \begin{macrocode}
\def\cloze@set@to@global{%
 \directlua{cloze.set_is_global(true)}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@to@local}
%    \begin{macrocode}
\def\cloze@set@to@local{%
  \directlua{
  cloze.unset_local_options()
  cloze.set_is_global(false)
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@option}
%    \begin{macrocode}
\def\cloze@set@option[#1]#2{%
  \directlua{cloze.set_option('#1', '#2')}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@color}
%    \begin{macrocode}
\def\cloze@color#1{\csname\string\color@#1\endcsname}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@set@local@options}
%    \begin{macrocode}
\def\cloze@set@local@options#1{%
  \cloze@set@to@local%
  \kvsetkeys{CLZ}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@start@marker}
%    \begin{macrocode}
\def\cloze@start@marker#1{%
  \strut\directlua{
    cloze.register('#1')
    cloze.marker('#1', 'start')
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@stop@marker}
%    \begin{macrocode}
\def\cloze@stop@marker#1{%
  \strut\directlua{
    cloze.marker('#1', 'stop')
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze@margin}
%    \begin{macrocode}
\def\cloze@margin#1{%
  \directlua{cloze.margin()}%
  #1%
  \directlua{cloze.margin()}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Options}
%
%    \begin{macrocode}
\cloze@set@to@global
%    \end{macrocode}
%
%
% We use the abbreviation |CLZ| as family name and prefix.
%    \begin{macrocode}
\SetupKeyvalOptions{
  family=CLZ,
  prefix=CLZ@
}
%    \end{macrocode}
%
%
% \paragraph{\tt{align}}
%
% Affects only \cmd{\clozefix}.
%    \begin{macrocode}
\DeclareStringOption{align}
\define@key{CLZ}{align}[]{\cloze@set@option[align]{#1}}
%    \end{macrocode}
%
%
% \paragraph{\tt{distance}}
%
%    \begin{macrocode}
\DeclareStringOption{distance}
\define@key{CLZ}{distance}[]{\cloze@set@option[distance]{#1}}
%    \end{macrocode}
%
%
% \paragraph{\tt{hide}}
%
%    \begin{macrocode}
\DeclareVoidOption{hide}{%
  \cloze@set@option[hide]{true}%
  \cloze@set@option[show]{false}%
}
%    \end{macrocode}
%
%
% \paragraph{\tt{linecolor}}
%
%    \begin{macrocode}
\DeclareStringOption{linecolor}
\define@key{CLZ}{linecolor}[]{%
  \cloze@set@option[linecolor]{\cloze@color{#1}}%
}
%    \end{macrocode}
%
%
% \paragraph{\tt{margin}}
%
%    \begin{macrocode}
\DeclareStringOption{margin}
\define@key{CLZ}{margin}[]{\cloze@set@option[margin]{#1}}
%    \end{macrocode}
%
%
% \paragraph{\tt{show}}
%
%    \begin{macrocode}
\DeclareVoidOption{show}{%
  \cloze@set@option[show]{true}%
  \cloze@set@option[hide]{false}%
}
%    \end{macrocode}
%
%
% \paragraph{\tt{textcolor}}
%
%    \begin{macrocode}
\DeclareStringOption{textcolor}
\define@key{CLZ}{textcolor}[]{%
  \cloze@set@option[textcolor]{\cloze@color{#1}}%
}
%    \end{macrocode}
%
%
% \paragraph{\tt{thickness}}
%
%    \begin{macrocode}
\DeclareStringOption{thickness}
\define@key{CLZ}{thickness}[]{\cloze@set@option[thickness]{#1}}
%    \end{macrocode}
%
%
% \paragraph{\tt{width}}
% Affects only \cmd{\clozefix}
%    \begin{macrocode}
\DeclareStringOption{width}
\define@key{CLZ}{width}[]{\cloze@set@option[width]{#1}}
%    \end{macrocode}
%
%    \begin{macrocode}
\ProcessKeyvalOptions{CLZ}
%    \end{macrocode}
%
% \subsubsection{Public macros}
%
% \begin{macro}{\clozeset}
%    \begin{macrocode}
\newcommand{\clozeset}[1]{%
  \cloze@set@to@global%
  \kvsetkeys{CLZ}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clozereset}
%    \begin{macrocode}
\newcommand{\clozereset}{%
  \directlua{cloze.reset()}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clozeshow}
%    \begin{macrocode}
\newcommand{\clozeshow}{%
  \clozeset{show}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clozehide}
%    \begin{macrocode}
\newcommand{\clozehide}{%
  \clozeset{hide}
}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\clozefont}
%    \begin{macrocode}
\newcommand{\clozefont}{\itshape}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozesetfont}
%    \begin{macrocode}
\newcommand{\clozesetfont}[1]{%
  \renewcommand{\clozefont}[1]{%
    #1%
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cloze}
%    \begin{macrocode}
\newcommand{\cloze}[2][]{%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{basic}%
  {%
    \clozefont\relax%
    \cloze@margin{#2}%
  }%
  \cloze@stop@marker{basic}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozefix}
% Creates a cloze on one line with a fixed length.
%    \begin{macrocode}
\newcommand{\clozefix}[2][]{%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{fix}%
  {%
    \clozefont\relax%
    \cloze@margin{#2}%
  }%
  \cloze@stop@marker{fix}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{environment}{clozepar}
%    \begin{macrocode}
\newenvironment{clozepar}[1][]%
{%
  \par%
  \cloze@set@local@options{#1}%
  \cloze@start@marker{par}%
  \clozefont\relax%
}%
{%
  \cloze@stop@marker{par}%
  \par%
  \directlua{cloze.unregister('par')}%
}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{macro}{\clozefil}
%    \begin{macrocode}
\newcommand{\clozefil}[2][]{%
  \cloze[#1]{#2}\clozelinefil[#1]%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\clozeline}
%
%    \begin{macrocode}
\newcommand{\clozeline}[1][]{%
  \cloze@set@local@options{#1}%
  \directlua{cloze.line()}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\clozelinefil}
%
%    \begin{macrocode}
\newcommand{\clozelinefil}[1][]{%
  \cloze@set@local@options{#1}%
  \strut%
  \directlua{cloze.hfill()}%
  \strut%
}
%    \end{macrocode}
% \end{macro}
%
%
% \iffalse
%</package>
%<*lua>
% \fi
% \subsection{The file \tt{cloze.lua}}
%    \begin{macrocode}
if not modules then modules = { } end modules ['cloze'] = {
  version   = '0.1',
  comment   = 'cloze',
  author    = 'Josef Friedrich, R.-M. Huber',
  copyright = 'Josef Friedrich, R.-M. Huber',
  license   = 'The LaTeX Project Public License Version 1.3c 2008-05-04'
}
%    \end{macrocode}
%
%    \begin{macrocode}
local nodex = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local registry = {}
registry.user_id = 3121978
registry.storage = {}
registry.defaults = {
  ['align'] = 'l',
  ['distance'] = '1.5pt',
  ['hide'] = false,
  ['linecolor'] = '0 0 0 rg 0 0 0 RG', -- black
  ['margin'] = '3pt',
  ['resetcolor'] = '0 0 0 rg 0 0 0 RG', -- black
  ['show_text'] = true,
  ['show'] = true,
  ['textcolor'] = '0 0 1 rg 0 0 1 RG', -- blue
  ['thickness'] = '0.1pt',
  ['width'] = '2cm',
}
registry.global_options = {}
registry.local_options = {}
%    \end{macrocode}
%
%    \begin{macrocode}
local cloze = {}
local base = {}
base.is_registered = {}
%    \end{macrocode}
%
% \subsubsection{Create functions}
%    \begin{macrocode}
function nodex.create_colorstack(data)
  if not data then
    data = '0 0 0 rg 0 0 0 RG' -- black
  end

  local whatsit = node.new('whatsit', 'pdf_colorstack')
  whatsit.stack = 0
  whatsit.data = data

  return whatsit
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.create_color(option)
  local data

  if option == 'line' then
    data = registry.get_value('linecolor')
  elseif option == 'text' then
    data = registry.get_value('textcolor')
  elseif option == 'reset' then
    data = nil
  else
    data = nil
  end

  return nodex.create_colorstack(data)
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.create_line(width)
  local rule = node.new(node.id('rule'))
  local thickness = tex.sp(registry.get_value('thickness'))
  local distance = tex.sp(registry.get_value('distance'))

  rule.depth = distance + thickness
  rule.height = - distance
  rule.width = width

  return rule
end
%    \end{macrocode}
%
% Append rule and kern to the node list.
%    \begin{macrocode}
function nodex.insert_line(head, current, width)
  local rule = nodex.create_line(width)

  head, new = node.insert_after(head, current, nodex.create_color('line'))
  head, new = node.insert_after(head, new, rule)
  head, new = node.insert_after(head, new, nodex.create_color('reset'))

  return head, new
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.write_line()
  node.write(nodex.create_color('line'))
  node.write(nodex.create_line(tex.sp(registry.get_value('width'))))
  node.write(nodex.create_color('reset'))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.create_kern(width)
  local kern = node.new(node.id('kern'))
  kern.kern = width
  return kern
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.create_hfill()
  local glue = node.new('glue')
  glue.subtype = 100

  local glue_spec = node.new('glue_spec')
  glue_spec.stretch = 65536
  glue_spec.stretch_order = 3

  glue.spec = glue_spec

  local rule = nodex.create_line(0)
  rule.dir = 'TLT'

  glue.leader = rule

  return glue
end
%    \end{macrocode}
%
% \subsubsection{Insert functions}
%
%    \begin{macrocode}
function nodex.write_hfill()
  node.write(nodex.create_color('line'))
  node.write(nodex.create_hfill())
  node.write(nodex.create_color('reset'))
end
%    \end{macrocode}
%
%    \begin{macrocode}
function nodex.write_margin()
  local kern = nodex.create_kern(tex.sp(registry.get_value('margin')))
  node.write(kern)
end
%    \end{macrocode}
%
% \subsubsection{registry}
%
% Functions to deal with option handling and storing them in a lua
% table.
%
%    \begin{macrocode}
function registry.create_marker(index)
  local marker = node.new('whatsit','user_defined')
  marker.type = 100 -- number
  marker.user_id = registry.user_id
  marker.value = index

  return marker
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.check_marker(item, mode, position)
  local data = registry.marker_data(item)

  if data and data.mode == mode and data.position == position then
    return true
  else
    return false
  end
end
%    \end{macrocode}
%
% |registry.index| is a counter. Increase the counter by one and then
% return it.
%
%    \begin{macrocode}
function registry.get_index()
  if not registry.index then
    registry.index = 0
  end

  registry.index = registry.index + 1
  return registry.index
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_option(key, value)
  if value == '' or value == '\\color@ ' then
    return false
  end

  if registry.is_global == true then
    registry.global_options[key] = value
  else
    registry.local_options[key] = value
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_is_global(value)
  registry.is_global = value
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.unset_local_options()
  registry.local_options = {}
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.unset_global_options()
  registry.global_options = {}
end
%    \end{macrocode}

%    \begin{macrocode}
function registry.set(mode, position)
  local index = registry.get_index()
  local data = {
    ['mode'] = mode,
    ['position'] = position
  }
  data.values = registry.local_options
  registry.storage[index] = data
  return index
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_storage(index)
  return registry.storage[index]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.set_show_text(options)
  if not options then
    return nil
  end

  if options.hide == true or options.hide == 'true'  then
    return false
  elseif options.show == true or options.show == 'true'  then
    return true
  else
    return nil
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.marker_data(item)
  if item.id == node.id('whatsit')
    and item.subtype == 44
    and item.user_id == registry.user_id then
    return registry.get_storage(item.value)
  else
    return false
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.marker_values(item)
  local data = registry.marker_data(item)
  registry.local_options = data.values
  return data.values
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_marker(item, mode, position)
  local out

  if registry.check_marker(item, mode, position) then
    registry.marker = item
    out = item
  else
    out = false
  end

  if out and position == 'start' then
    registry.marker_values(item)
  end

  return out
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_value(key)
  if registry.has_value(registry.local_options[key]) then
    return registry.local_options[key]
  end

  if registry.has_value(registry.global_options[key]) then
    return registry.global_options[key]
  end

  return registry.defaults[key]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.has_value(value)
  if value == nil or value == '' or value == '\\color@ ' then
    return false
  else
    return true
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.get_defaults(key)
  return registry.defaults[key]
end
%    \end{macrocode}
%
%    \begin{macrocode}
function registry.show_cloze_text()
  if
    registry.get_value('show') == true
  or
    registry.get_value('show') == 'true'
  then
    return true
  else
    return false
  end
end
%    \end{macrocode}
%
% \subsubsection{cloze}
%
% To make life easier: We add at the beginning of each line a strut. Now
% we can add rule, color etc. nodes AFTER the first node of a line not
% BEFORE. AFTER is much more easier.
%
%    \begin{macrocode}
function cloze.basic(head)
  local n = {} -- node
  local b = {} -- boolean
  local l = {} -- length
  local t = {} -- temp

  for hlist in node.traverse_id(node.id('hlist'), head) do

    n.head = hlist.head
    n.strut = node.insert_before(n.head, n.head, nodex.create_kern(0))
    hlist.head = n.head.prev

    if b.line_end then
      b.init_cloze = true
    end

    n.current = hlist.head

    while n.current do

      if registry.check_marker(n.current, 'basic', 'start') or b.init_cloze then

        n.marker = registry.get_marker(n.current, 'basic', 'start')

        node.insert_after(hlist.head, n.current, nodex.create_color('text'))

        b.init_cloze = false

        n.stop = n.current
        while n.stop.next do

          b.line_end = true

          if registry.check_marker(n.stop, 'basic', 'stop') then
            b.line_end = false
            break
          end

          n.stop = n.stop.next
        end

        l.line_width = node.dimensions(
          hlist.glue_set,
          hlist.glue_sign,
          hlist.glue_order,
          n.current,
          n.stop.next
        )

        head, n.line = nodex.insert_line(
          head,
          n.current,
          l.line_width
        )

        if registry.show_cloze_text() then
          node.insert_after(head, n.line, nodex.create_kern(-l.line_width))
          node.insert_after(head, n.stop, nodex.create_color('reset'))
        else
          n.line.next = n.stop.next
          n.stop.prev = n.line.prev
        end

        n.current = n.stop.next
      else
        n.current = n.current.next
      end -- if

    end -- while

  end -- for

  return head
end -- function
%    \end{macrocode}
% Make cloze for macro clozefix
%
% Node list (show text)
%
% \begin{enumerate}
% \item W[n.start]
% \item R[n.line]
% \item K[n.kern\_start]
% \item W[textcolor]
% \item W[colorreset]
% \item K[n.kern\_stop]
% \item W[n.stop]
% \end{enumerate}
%
% Node list (hide text)
%
% \begin{enumerate}
% \item W[n.start]
% \item W[linecolor]
% \item R[length]
% \item W[colorreset]
% \item K[kern\_start]
% \item W[textcolor]
% \end{enumerate}
%
%    \begin{macrocode}
function cloze.fix_make(head, start, stop)
  local l = {} -- length

  l.width = tex.sp(registry.get_value('width'))

  local n = {} -- node
  n.start = start
  n.stop = stop

  l.text_width = node.dimensions(n.start, n.stop)

  local align = registry.get_value('align')

  if align == 'right' then
    l.kern_start = -l.text_width
    l.kern_stop = 0
  elseif align == 'center' then
    l.half = (l.width - l.text_width) / 2
    l.kern_start = -l.half - l.text_width
    l.kern_stop = l.half
  else
    l.kern_start = -l.width
    l.kern_stop = l.width - l.text_width
  end

  head, n.line = nodex.insert_line(head, n.start, l.width)

  if registry.show_cloze_text() then
    head, n.kern_start = node.insert_after(
      head,
      n.line,
      nodex.create_kern(l.kern_start)
    )
    node.insert_after(head, n.kern_start, nodex.create_color('text'))
    node.insert_before(head, n.stop, nodex.create_colorstack())
    node.insert_before(head, n.stop, nodex.create_kern(l.kern_stop))
  else
    n.line.next = n.stop.next
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function cloze.fix(head)
  local n = {} -- node

  n.start, n.stop = false
  for current in node.traverse_id(node.id('whatsit'), head) do

    if not n.start then
      n.start = registry.get_marker(current, 'fix', 'start')
    end
    if not n.stop then
      n.stop = registry.get_marker(current, 'fix', 'stop')
    end

    if n.start and n.stop then
      cloze.fix_make(head, n.start, n.stop)
      n.start, n.stop = false
    end
  end

  return head
end
%    \end{macrocode}
% Call for environment clozpar
%    \begin{macrocode}
function cloze.par(head)
  local l = {} -- length
  local n = {} -- node

  for hlist in node.traverse_id(node.id('hlist'), head) do

    for whatsit in node.traverse_id(node.id('whatsit'), hlist.head) do
      registry.get_marker(whatsit, 'par', 'start')
    end

    l.width = hlist.width

    n.head = hlist.head
    n.strut = node.insert_before(n.head, n.head, nodex.create_kern(0))
    hlist.head = n.head.prev

    head, n.rule = nodex.insert_line(head, n.strut, l.width)

    if registry.show_cloze_text() then
      head, n.kern = node.insert_after(
        head,
        n.rule,
        nodex.create_kern(-l.width)
      )
      node.insert_after(head, n.kern, nodex.create_color('text'))

      n.tail = node.tail(n.head)
      node.insert_after(n.head, n.tail, nodex.create_color('reset'))
    else
      n.rule.next = nil
    end
  end

  return head
end
%    \end{macrocode}
%
% \subsubsection{base}
%
% Base functions which are accessible in the sty file.
%
%    \begin{macrocode}
function base.register(mode)
  if mode == 'par' then
    luatexbase.add_to_callback(
      'post_linebreak_filter',
      cloze.par,
      mode,
      1
    )
    return true
  end

  if not base.is_registered[mode] then
    if mode == 'basic' then
      luatexbase.add_to_callback(
        'post_linebreak_filter',
        cloze.basic,
        mode,
        1
      )
    elseif mode == 'fix' then
      luatexbase.add_to_callback(
        'pre_linebreak_filter',
        cloze.fix,
        mode,
        1
      )
    else
      return false
    end
    base.is_registered[mode] = true
  end
end
%    \end{macrocode}
% Register the callbacks.
%    \begin{macrocode}
function base.unregister(mode)
  if mode == 'basic' then
    luatexbase.remove_from_callback('post_linebreak_filter', mode)
  elseif mode == 'fix' then
    luatexbase.remove_from_callback('pre_linebreak_filter', mode)
  else
    luatexbase.remove_from_callback('post_linebreak_filter', mode)
  end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.set_global_options(options)
  options.show_text = base.show_text
  registry.global_options = options
end
%    \end{macrocode}
%
%    \begin{macrocode}
function base.marker(mode, position)
  local index = registry.set(mode, position)
  local marker = registry.create_marker(index)
  node.write(marker)
end
%    \end{macrocode}
% Publish some functions to sty file.
%    \begin{macrocode}
base.hfill = nodex.write_hfill
base.line = nodex.write_line
base.margin = nodex.write_margin
base.set_option = registry.set_option
base.set_is_global = registry.set_is_global
base.unset_local_options = registry.unset_local_options
base.reset = registry.unset_global_options
base.get_defaults = registry.get_defaults
%    \end{macrocode}
%
%    \begin{macrocode}
return base
%    \end{macrocode}
% \iffalse
%</lua>
% \fi
%
% \Finale
\endinput
