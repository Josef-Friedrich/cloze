<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>The cloze package</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>cloze</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Local_Functions">Local Functions</a></li>
<li><a href="#Option_handling">Option handling </a></li>
<li><a href="#Assembly_to_cloze_texts">Assembly to cloze texts </a></li>
<li><a href="#Class_HlistNode">Class HlistNode </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>cloze</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>cloze</code></h1>
<p>

<h3>Naming conventions</h3>


<ul>
    <li><em>Variable</em> names for <em>nodes</em> are suffixed with <code>_node</code>, for example
    <code>head_node</code>.</li>
</ul>
</p>
<p>

<ul>
    <li><em>Variable</em> names for <em>lengths</em> (dimensions) are suffixed with
    <code>_length</code>, for example <code>width</code>.</li>
</ul>
</p>


<h2><a href="#Local_Functions">Local Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tex_printf">tex_printf (s, ...)</a></td>
	<td class="summary">

</td>
	</tr>
</table>
<h2><a href="#Option_handling">Option handling </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#config">config</a></td>
	<td class="summary">All values and functions, which are related to the option
management, are stored in a table called <a href="index.html#config">config</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#user_id">user_id</a></td>
	<td class="summary">I didn’t know what value I should take as <a href="index.html#user_id">user_id</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#storage">storage</a></td>
	<td class="summary">Store all local options of the markers.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#defaults">defaults</a></td>
	<td class="summary">The default options.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#global_options">global_options</a></td>
	<td class="summary">The global options set by the user.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#local_options">local_options</a></td>
	<td class="summary">The local options.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_index">get_index ()</a></td>
	<td class="summary"><code>index</code> is a counter.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_storage">get_storage (index)</a></td>
	<td class="summary">The function <code>get_storage()</code> retrieves values which belong
 to a whatsit marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_storage">set_storage (mode, position)</a></td>
	<td class="summary"><code>set_storage()</code> stores the local options in the Lua table
 <a href="index.html#storage">storage</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#create_marker">create_marker (index)</a></td>
	<td class="summary">We create a user defined whatsit node that can store a number (type
 = 100).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#write_marker">write_marker (mode, position)</a></td>
	<td class="summary">Write a marker node to TeX's current node list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#is_marker">is_marker (item)</a></td>
	<td class="summary">Check if the given node is a marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_marker_data">get_marker_data (item)</a></td>
	<td class="summary">Test whether the node <code>item</code> is a marker and retrieve the
the corresponding config data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#check_marker">check_marker (head_node, mode, position)</a></td>
	<td class="summary">This functions tests, whether the given node <code>item</code> is a marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_marker_values">get_marker_values (marker)</a></td>
	<td class="summary">First this function saves the associatied values of a marker to the
local options table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_marker">get_marker (head_node, mode, position)</a></td>
	<td class="summary"><a href="index.html#get_marker">get_marker</a> returns the given marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#remove_marker">remove_marker (marker)</a></td>
	<td class="summary">This function removes a given whatsit marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_option">set_option (key, value)</a></td>
	<td class="summary">This function stores a value <code>value</code> and his associated key <code>key</code>
 either to the global (<a href="index.html#global_options">global_options</a>) or to the local
 (<a href="index.html#local_options">local_options</a>) option table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_is_global">set_is_global (is_global)</a></td>
	<td class="summary">Set the variable <code>is_global</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#unset_local_options">unset_local_options ()</a></td>
	<td class="summary">This function unsets the local options.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#unset_global_options">unset_global_options ()</a></td>
	<td class="summary"><a href="index.html#unset_global_options">unset_global_options</a> empties the global options storage.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#has_value">has_value (value)</a></td>
	<td class="summary">This function tests whether the value <code>value</code> is not empty and has a
value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_value">get_value (key)</a></td>
	<td class="summary">Retrieve a value from a given key.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_value_show">get_value_show ()</a></td>
	<td class="summary">The function <code>get_value_show()</code> returns the boolean value
<code>true</code> if the option <code>show</code> is true.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_defaults">get_defaults (key)</a></td>
	<td class="summary">Return the default value of the given option.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#parse_options">parse_options (kv_string, to_global)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#create_color">create_color (kind, command)</a></td>
	<td class="summary"><code>utils.create_color()</code> is a wrapper for the function
<code>utils.create_colorstack()</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#create_line">create_line (width)</a></td>
	<td class="summary">Create a rule node, which is used as a line for the cloze texts.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#insert_list">insert_list (position, current, list, head_node)</a></td>
	<td class="summary">Insert a <code>list</code> of nodes after or before the <code>current</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#insert_line">insert_line (current, width)</a></td>
	<td class="summary">Enclose a rule node (cloze line) with two PDF colorstack whatsits.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#write_line_nodes">write_line_nodes ()</a></td>
	<td class="summary">Encloze a rule node with color nodes as the function
 <code>utils.insert_line</code> does.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#create_linefil">create_linefil ()</a></td>
	<td class="summary">Create a line which stretches indefinitely in the
horizontal direction.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#write_linefil_nodes">write_linefil_nodes ()</a></td>
	<td class="summary">Surround a indefinitely strechable line with color whatsits and puts
it to TeX’s ‘current (node) list’ (write).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#create_kern_node">create_kern_node (width)</a></td>
	<td class="summary">Create a kern node with a given width.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#insert_strut_into_hlist">insert_strut_into_hlist (hlist_node)</a></td>
	<td class="summary">Add at the beginning of each <code>hlist</code> node list a strut (a invisible
character).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#write_margin_node">write_margin_node ()</a></td>
	<td class="summary">Write a kern node to the current node list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#search_hlist">search_hlist (head_node)</a></td>
	<td class="summary">Search for a <code>hlist</code> (subtype <code>line</code>) and insert a strut node into
the list if a hlist is found.</td>
	</tr>
</table>
<h2><a href="#Assembly_to_cloze_texts">Assembly to cloze texts </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#make_basic">make_basic (head_node_input)</a></td>
	<td class="summary">Assemble a possibly multiline cloze.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#make_single">make_single (start_node, stop_node, parent_node)</a></td>
	<td class="summary">Make a single gap.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#search_stop">search_stop (start_node, parent_node)</a></td>
	<td class="summary">Search for a stop marker or make a cloze up to the end of the node
list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#continue_cloze">continue_cloze (parent_node)</a></td>
	<td class="summary">Continue a multiline cloze.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#search_start">search_start (head_node, parent_node)</a></td>
	<td class="summary">Search for a start marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#make_fix">make_fix (head_node_input)</a></td>
	<td class="summary">The corresponding LaTeX command to this Lua function is <code>\clozefix</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#make_single">make_single (start, stop)</a></td>
	<td class="summary">The function <a href="index.html#make_single">make_single</a> generates a gap of fixed width.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#make_fix_recursion">make_fix_recursion (head_node)</a></td>
	<td class="summary">Function to recurse the node list and search after marker.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#make_par">make_par (head_node)</a></td>
	<td class="summary">The corresponding LaTeX environment to this lua function is
<code>clozepar</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#add_additional_lines">add_additional_lines (last_hlist_node, count)</a></td>
	<td class="summary">Add multiple empty lines at the end of a paragraph.</td>
	</tr>
</table>
<h2><a href="#Class_HlistNode">Class HlistNode </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#HlistNode.hlist_node">HlistNode.hlist_node</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HlistNode.register">HlistNode.register (callback_name, func, description)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HlistNode.unregister">HlistNode.unregister (callback_name, description)</a></td>
	<td class="summary">

</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HlistNode.is_registered">HlistNode.is_registered</a></td>
	<td class="summary">Store informations if the callbacks are already registered for
a certain mode (<code>basic</code>, <code>fix</code>, <code>par</code>).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HlistNode:register_callbacks">HlistNode:register_callbacks (mode)</a></td>
	<td class="summary">Register the functions <a href="index.html#make_par">make_par</a>, <a href="index.html#make_basic">make_basic</a> and
<a href="index.html#make_fix">make_fix</a> as callbacks.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#HlistNode:unregister_callbacks">HlistNode:unregister_callbacks (mode)</a></td>
	<td class="summary">Delete the registered functions from the Lua callbacks.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Local_Functions"></a>Local Functions</h2>

    <dl class="function">
    <dt>
    <a name = "tex_printf"></a>
    <strong>tex_printf (s, ...)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">s</span>
         string
        </li>
        <li><span class="parameter">...</span>
         any
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header has-description"><a name="Option_handling"></a>Option handling </h2>

          <div class="section-description">



<p>The table <a href="index.html#config">config</a> bundles functions that deal with the option
handling.</p>


<h2>Marker processing (marker)</h2>


<p>A marker is a whatsit node of the subtype <code>user_defined</code>. A marker
has two purposes:</p>

<ul>
    <li>Mark the begin and the end of a gap.</li>
    <li>Store a index number, that points to a Lua table, which holds some
    additional data like the local options.</li>
</ul>


          </div>
    <dl class="function">
    <dt>
    <a name = "config"></a>
    <strong>config</strong>
    </dt>
    <dd>
    All values and functions, which are related to the option
management, are stored in a table called <a href="index.html#config">config</a>.







</dd>
    <dt>
    <a name = "user_id"></a>
    <strong>user_id</strong>
    </dt>
    <dd>
    I didn’t know what value I should take as <a href="index.html#user_id">user_id</a>.  Therefore I
took my birthday and transformed it into a large number.







</dd>
    <dt>
    <a name = "storage"></a>
    <strong>storage</strong>
    </dt>
    <dd>
    Store all local options of the markers. </p>

<p><code><pre>
storage = {
  {</p>
<pre><code>mode = "basic",
position = "start",
values = {
  distance = "3mm"
}
</code></pre>
<p>  },
  {</p>
<pre><code>mode = "basic",
position = "stop"
</code></pre>
<p>  }
}</pre></code>







</dd>
    <dt>
    <a name = "defaults"></a>
    <strong>defaults</strong>
    </dt>
    <dd>
    The default options.


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">[align]</span>



        </li>
        <li><span class="parameter">[boxheight]</span>



        </li>
        <li><span class="parameter">[boxrule]</span>



        </li>
        <li><span class="parameter">[boxwidth]</span>



        </li>
        <li><span class="parameter">[distance]</span>



        </li>
        <li><span class="parameter">[hide]</span>



        </li>
        <li><span class="parameter">[linecolor]</span>



        </li>
        <li><span class="parameter">[margin]</span>



        </li>
        <li><span class="parameter">[minlines]</span>



        </li>
        <li><span class="parameter">[show_text]</span>



        </li>
        <li><span class="parameter">[show]</span>



        </li>
        <li><span class="parameter">[spacing]</span>



        </li>
        <li><span class="parameter">[textcolor]</span>



        </li>
        <li><span class="parameter">[thickness]</span>



        </li>
        <li><span class="parameter">[width]</span>



        </li>
    </ul>





</dd>
    <dt>
    <a name = "global_options"></a>
    <strong>global_options</strong>
    </dt>
    <dd>
    The global options set by the user.







</dd>
    <dt>
    <a name = "local_options"></a>
    <strong>local_options</strong>
    </dt>
    <dd>
    The local options.







</dd>
    <dt>
    <a name = "get_index"></a>
    <strong>get_index ()</strong>
    </dt>
    <dd>
    <code>index</code> is a counter.  The functions <code>get_index()</code>
increases the counter by one and then returns it.



    <h3>Returns:</h3>
    <ol>

        integer # The index number of the corresponding table in <a href="index.html#storage">storage</a>.
    </ol>




</dd>
    <dt>
    <a name = "get_storage"></a>
    <strong>get_storage (index)</strong>
    </dt>
    <dd>
    The function <code>get_storage()</code> retrieves values which belong
 to a whatsit marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index</span>
         integer # The argument <code>index</code> is a numeric value.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Marker value
    </ol>




</dd>
    <dt>
    <a name = "set_storage"></a>
    <strong>set_storage (mode, position)</strong>
    </dt>
    <dd>
    <code>set_storage()</code> stores the local options in the Lua table
 <a href="index.html#storage">storage</a>. </p>

<p>It returns a numeric index number. This index number is the key,
where the local options in the Lua table are stored.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mode</span>
         MarkerMode
        </li>
        <li><span class="parameter">position</span>
         MarkerPosition
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        number # The index number of the corresponding table in
  <a href="index.html#storage">storage</a>.
    </ol>




</dd>
    <dt>
    <a name = "create_marker"></a>
    <strong>create_marker (index)</strong>
    </dt>
    <dd>
    We create a user defined whatsit node that can store a number (type
 = 100). </p>

<p>In order to distinguish this node from other user defined whatsit
nodes we set the <a href="index.html#user_id">user_id</a> to a large number. We call this whatsit
node a marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index</span>
         number The argument <code>index</code> is a number, which is associated to values in the <a href="index.html#storage">storage</a> table.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        UserDefinedWhatsitNode
    </ol>




</dd>
    <dt>
    <a name = "write_marker"></a>
    <strong>write_marker (mode, position)</strong>
    </dt>
    <dd>
    Write a marker node to TeX's current node list.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mode</span>
         MarkerMode
        </li>
        <li><span class="parameter">position</span>
         MarkerPosition
        </li>
    </ul>





</dd>
    <dt>
    <a name = "is_marker"></a>
    <strong>is_marker (item)</strong>
    </dt>
    <dd>
    Check if the given node is a marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">item</span>
         Node
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        boolean
    </ol>




</dd>
    <dt>
    <a name = "get_marker_data"></a>
    <strong>get_marker_data (item)</strong>
    </dt>
    <dd>
    Test whether the node <code>item</code> is a marker and retrieve the
the corresponding config data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">item</span>
         UserDefinedWhatsitNode # The argument <code>item</code> is a node of unspecified type.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        table|false # The marker data.
    </ol>




</dd>
    <dt>
    <a name = "check_marker"></a>
    <strong>check_marker (head_node, mode, position)</strong>
    </dt>
    <dd>
    This functions tests, whether the given node <code>item</code> is a marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node</span>
         Node # The current node.
        </li>
        <li><span class="parameter">mode</span>
         MarkerMode
        </li>
        <li><span class="parameter">position</span>
         MarkerPosition
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        boolean
    </ol>




</dd>
    <dt>
    <a name = "get_marker_values"></a>
    <strong>get_marker_values (marker)</strong>
    </dt>
    <dd>
    First this function saves the associatied values of a marker to the
local options table.  Second it returns this values. The argument
<code>marker</code> is a whatsit node.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">marker</span>
         UserDefinedWhatsitNode
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        unknown
    </ol>




</dd>
    <dt>
    <a name = "get_marker"></a>
    <strong>get_marker (head_node, mode, position)</strong>
    </dt>
    <dd>
    <a href="index.html#get_marker">get_marker</a> returns the given marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node</span>
         Node # The current node.
        </li>
        <li><span class="parameter">mode</span>
         MarkerMode
        </li>
        <li><span class="parameter">position</span>
         MarkerPosition
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        false|Node # The node if <code>head_node</code> is a marker node.
    </ol>




</dd>
    <dt>
    <a name = "remove_marker"></a>
    <strong>remove_marker (marker)</strong>
    </dt>
    <dd>
    This function removes a given whatsit marker. </p>

<p>It only deletes a node, if a marker is given.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">marker</span>
         Node
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        Node|nil head</li>
        <li>
        Node|nil current</li>
    </ol>




</dd>
    <dt>
    <a name = "set_option"></a>
    <strong>set_option (key, value)</strong>
    </dt>
    <dd>
    This function stores a value <code>value</code> and his associated key <code>key</code>
 either to the global (<a href="index.html#global_options">global_options</a>) or to the local
 (<a href="index.html#local_options">local_options</a>) option table. </p>

<p>The global boolean variable <a href="index.html#local_options">local_options</a> controls in
which table the values are stored.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">key</span>
         string # The option key.
        </li>
        <li><span class="parameter">value</span>
         any # The value that is stored under the options key.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "set_is_global"></a>
    <strong>set_is_global (is_global)</strong>
    </dt>
    <dd>
    Set the variable <code>is_global</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">is_global</span>
         boolean
        </li>
    </ul>





</dd>
    <dt>
    <a name = "unset_local_options"></a>
    <strong>unset_local_options ()</strong>
    </dt>
    <dd>
    This function unsets the local options.







</dd>
    <dt>
    <a name = "unset_global_options"></a>
    <strong>unset_global_options ()</strong>
    </dt>
    <dd>
    <a href="index.html#unset_global_options">unset_global_options</a> empties the global options storage.







</dd>
    <dt>
    <a name = "has_value"></a>
    <strong>has_value (value)</strong>
    </dt>
    <dd>
    This function tests whether the value <code>value</code> is not empty and has a
value.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         any # A value of different types.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        boolean # True is the value is set otherwise false.
    </ol>




</dd>
    <dt>
    <a name = "get_value"></a>
    <strong>get_value (key)</strong>
    </dt>
    <dd>
    Retrieve a value from a given key.  First search for the value in the
local options, then in the global options. If both option storages are
empty, the default value will be returned.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">key</span>
         string # The name of the options key.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        any # The value of the corresponding option key.
    </ol>




</dd>
    <dt>
    <a name = "get_value_show"></a>
    <strong>get_value_show ()</strong>
    </dt>
    <dd>
    The function <code>get_value_show()</code> returns the boolean value
<code>true</code> if the option <code>show</code> is true.  In contrast to the function
<code>get_value()</code> it converts the string value `true' to a
boolean value.



    <h3>Returns:</h3>
    <ol>

        boolean
    </ol>




</dd>
    <dt>
    <a name = "get_defaults"></a>
    <strong>get_defaults (key)</strong>
    </dt>
    <dd>
    Return the default value of the given option.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">key</span>
         any # The name of the options key.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        any # The corresponding value of the options key.
    </ol>




</dd>
    <dt>
    <a name = "parse_options"></a>
    <strong>parse_options (kv_string, to_global)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">kv_string</span>
         string
        </li>
        <li><span class="parameter">to_global</span>
        ? boolean
        </li>
    </ul>





</dd>
    <dt>
    <a name = "create_color"></a>
    <strong>create_color (kind, command)</strong>
    </dt>
    <dd>
    <code>utils.create_color()</code> is a wrapper for the function
<code>utils.create_colorstack()</code>.  It queries the current values of the
options <code>linecolor</code> and <code>textcolor</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">kind</span>
         'line'|'text'
        </li>
        <li><span class="parameter">command</span>
         'push'|'pop'
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        PdfColorstackWhatsitNode
    </ol>




</dd>
    <dt>
    <a name = "create_line"></a>
    <strong>create_line (width)</strong>
    </dt>
    <dd>
    Create a rule node, which is used as a line for the cloze texts.  The
<code>depth</code> and the <code>height</code> of the rule are calculated form the options
<code>thickness</code> and <code>distance</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">width</span>
         number # The argument <code>width</code> must have the length unit <strong>scaled points</strong>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        RuleNode
    </ol>




</dd>
    <dt>
    <a name = "insert_list"></a>
    <strong>insert_list (position, current, list, head_node)</strong>
    </dt>
    <dd>
    Insert a <code>list</code> of nodes after or before the <code>current</code>.  The <code>head</code>
argument is optional. In some edge cases it is unfortately necessary.
if <code>head</code> is omitted the <code>current</code> node is used.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">position</span>
         'before'|'after' # The argument <code>position</code> can take the values <code>&apos;after&apos;</code> or <code>&apos;before&apos;</code>.
        </li>
        <li><span class="parameter">current</span>
         Node
        </li>
        <li><span class="parameter">list</span>
         table
        </li>
        <li><span class="parameter">head_node</span>
        ? Node
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Node
    </ol>




</dd>
    <dt>
    <a name = "insert_line"></a>
    <strong>insert_line (current, width)</strong>
    </dt>
    <dd>
    Enclose a rule node (cloze line) with two PDF colorstack whatsits.
The first colorstack node colors the line, the second resets the
color.</p>

<p><strong>Node list</strong>: <code>whatsit:pdf_colorstack</code> (line_color) - <code>rule</code> (width) - <code>whatsit:pdf_colorstack</code> (reset_color)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">current</span>
         Node
        </li>
        <li><span class="parameter">width</span>
         number
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Node
    </ol>




</dd>
    <dt>
    <a name = "write_line_nodes"></a>
    <strong>write_line_nodes ()</strong>
    </dt>
    <dd>
    Encloze a rule node with color nodes as the function
 <code>utils.insert_line</code> does. </p>

<p>In contrast to -<code>utils.insert_line</code> the three nodes are appended to
TeX’s ‘current-list’. They are not inserted in a node list, which
is accessed by a Lua callback.</p>

<p><strong>Node list</strong>: <code>whatsit:pdf_colorstack</code> (line_color) - <code>rule</code> (width) - <code>whatsit:pdf_colorstack</code> (reset_color)







</dd>
    <dt>
    <a name = "create_linefil"></a>
    <strong>create_linefil ()</strong>
    </dt>
    <dd>
    Create a line which stretches indefinitely in the
horizontal direction.



    <h3>Returns:</h3>
    <ol>

        GlueNode
    </ol>




</dd>
    <dt>
    <a name = "write_linefil_nodes"></a>
    <strong>write_linefil_nodes ()</strong>
    </dt>
    <dd>
    Surround a indefinitely strechable line with color whatsits and puts
it to TeX’s ‘current (node) list’ (write).







</dd>
    <dt>
    <a name = "create_kern_node"></a>
    <strong>create_kern_node (width)</strong>
    </dt>
    <dd>
    Create a kern node with a given width.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">width</span>
         number # The argument <code>width</code> had to be specified in scaled points.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        KernNode
    </ol>




</dd>
    <dt>
    <a name = "insert_strut_into_hlist"></a>
    <strong>insert_strut_into_hlist (hlist_node)</strong>
    </dt>
    <dd>
    Add at the beginning of each <code>hlist</code> node list a strut (a invisible
character). </p>

<p>Now we can add line, color etc. nodes after the first node of a hlist
not before - after is much more easier.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">hlist_node</span>
         HlistNode
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        HlistNode hlist_node</li>
        <li>
        Node strut_node</li>
        <li>
        Node prev<em>head</em>node</li>
    </ol>




</dd>
    <dt>
    <a name = "write_margin_node"></a>
    <strong>write_margin_node ()</strong>
    </dt>
    <dd>
    Write a kern node to the current node list.  This kern node can be
used to build a margin.







</dd>
    <dt>
    <a name = "search_hlist"></a>
    <strong>search_hlist (head_node)</strong>
    </dt>
    <dd>
    Search for a <code>hlist</code> (subtype <code>line</code>) and insert a strut node into
the list if a hlist is found.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node</span>
         Node # The head of a node list.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        HlistNode|nil hlist_node</li>
        <li>
        Node|nil strut_node</li>
        <li>
        Node|nil prev<em>head</em>node</li>
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Assembly_to_cloze_texts"></a>Assembly to cloze texts </h2>

    <dl class="function">
    <dt>
    <a name = "make_basic"></a>
    <strong>make_basic (head_node_input)</strong>
    </dt>
    <dd>
    Assemble a possibly multiline cloze. </p>

<p>The corresponding LaTeX command to this Lua function is <code>\cloze</code>.
This function is used by other cloze TeX macros too: <code>\clozenol</code>,
<code>\clozefil</code>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node_input</span>
         Node # The head of a node list.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Node # The head of the node list.
    </ol>




</dd>
    <dt>
    <a name = "make_single"></a>
    <strong>make_single (start_node, stop_node, parent_node)</strong>
    </dt>
    <dd>
    Make a single gap.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">start_node</span>
         Node # The node to start / begin a new cloze.
        </li>
        <li><span class="parameter">stop_node</span>
         Node # The node to stop / end a new cloze.
        </li>
        <li><span class="parameter">parent_node</span>
         HlistNode # The parent node (hlist) of the start and the stop node.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        Node|nil stop_node # The stop node.</li>
        <li>
        HlistNode parent_node # The parent node (hlist) of the stop node.</li>
    </ol>




</dd>
    <dt>
    <a name = "search_stop"></a>
    <strong>search_stop (start_node, parent_node)</strong>
    </dt>
    <dd>
    Search for a stop marker or make a cloze up to the end of the node
list.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">start_node</span>
         Node # The node to start a new cloze.
        </li>
        <li><span class="parameter">parent_node</span>
         HlistNode # The parent node (hlist) of the start node.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        Node|nil head_node # The fast forwarded new head of the node list.</li>
        <li>
        Node|nil parent_node # The parent node (hlist) of the head node.</li>
    </ol>




</dd>
    <dt>
    <a name = "continue_cloze"></a>
    <strong>continue_cloze (parent_node)</strong>
    </dt>
    <dd>
    Continue a multiline cloze.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">parent_node</span>
         Node # A parent node to search for a hlist node.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        Node|nil head_node # The fast forwarded new head of the node list.</li>
        <li>
        Node|nil parent_node # The parent node (hlist) of the head node.</li>
    </ol>




</dd>
    <dt>
    <a name = "search_start"></a>
    <strong>search_start (head_node, parent_node)</strong>
    </dt>
    <dd>
    Search for a start marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node</span>
         Node # The head of a node list.
        </li>
        <li><span class="parameter">parent_node</span>
         HlistNode # The parent node (hlist) of the head node.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Node
    </ol>




</dd>
    <dt>
    <a name = "make_fix"></a>
    <strong>make_fix (head_node_input)</strong>
    </dt>
    <dd>
    The corresponding LaTeX command to this Lua function is <code>\clozefix</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node_input</span>
         Node # The head of a node list.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "make_single"></a>
    <strong>make_single (start, stop)</strong>
    </dt>
    <dd>
    The function <a href="index.html#make_single">make_single</a> generates a gap of fixed width. </p>

<p><strong>Node lists</strong></p>

<p><strong>Show text:</strong></p>


<table>
<tbody>
  <tr>
    <td><code>start\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>user\_definded</code></td>
    <td><code>index</code></td>
  </tr>
  <tr>
    <td><code>line\_node</code></td>
    <td><code>rule</code></td>
    <td></td>
    <td><code>width</code></td>
  </tr>
  <tr>
    <td><code>kern\_start\_node</code></td>
    <td><code>kern</code></td>
    <td>&amp; Depends on <code>align</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>color\_text\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>pdf\_colorstack</code></td>
    <td>Text color</td>
  </tr>
  <tr>
    <td></td>
    <td><code>glyphs</code></td>
    <td>&amp; Text to show</td>
    <td></td>
  </tr>
  <tr>
    <td><code>color\_reset\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>pdf\_colorstack</code></td>
    <td>Reset color</td>
  </tr>
  <tr>
    <td><code>kern\_stop\_node</code></td>
    <td><code>kern</code></td>
    <td>&amp; Depends on <code>align</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>stop\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>user\_definded</code></td>
    <td><code>index</code></td>
  </tr>
</tbody>
</table>


<p><strong>Hide text:</strong></p>


<table>
<thead>
  <tr>
    <th><code>start\_node</code></th>
    <th><code>whatsit</code></th>
    <th><code>user\_definded</code></th>
    <th><code>index</code></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><code>line\_node</code></td>
    <td><code>rule</code></td>
    <td></td>
    <td><code>width</code></td>
  </tr>
  <tr>
    <td><code>stop\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>user\_definded</code></td>
    <td><code>index</code></td>
  </tr>
</tbody>
</table>


<p>Make a fixed sized cloze.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">start</span>
         Node # The node, where the gap begins
        </li>
        <li><span class="parameter">stop</span>
         Node # The node, where the gap ends
        </li>
    </ul>





</dd>
    <dt>
    <a name = "make_fix_recursion"></a>
    <strong>make_fix_recursion (head_node)</strong>
    </dt>
    <dd>
    Function to recurse the node list and search after marker.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node</span>
         Node # The head of a node list.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "make_par"></a>
    <strong>make_par (head_node)</strong>
    </dt>
    <dd>

<p>The corresponding LaTeX environment to this lua function is
<code>clozepar</code>. </p>

<p><strong>Node lists</strong></p>

<p><strong>Show text:</strong></p>


<table>
<thead>
  <tr>
    <th><code>strut\_node</code></th>
    <th><code>kern</code></th>
    <th></th>
    <th>width = 0</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><code>line\_node</code></td>
    <td><code>rule</code></td>
    <td></td>
    <td><code>width</code> (Width from hlist)</td>
  </tr>
  <tr>
    <td><code>kern\_node</code></td>
    <td><code>kern</code></td>
    <td></td>
    <td><code>-width</code></td>
  </tr>
  <tr>
    <td><code>color\_text\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>pdf\_colorstack</code></td>
    <td>Text color</td>
  </tr>
  <tr>
    <td></td>
    <td><code>glyphs</code></td>
    <td></td>
    <td>Text to show</td>
  </tr>
  <tr>
    <td><code>tail\_node</code></td>
    <td><code>glyph</code></td>
    <td></td>
    <td>Last glyph in hlist</td>
  </tr>
  <tr>
    <td><code>color\_reset\_node</code></td>
    <td><code>whatsit</code></td>
    <td><code>pdf\_colorstack</code></td>
    <td>Reset color</td>
  </tr>
</tbody>
</table>


<p><strong>Hide text:</strong></p>


<table>
<thead>
  <tr>
    <th><code>strut\_node</code></th>
    <th><code>kern</code></th>
    <th></th>
    <th>width = 0</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><code>line\_node</code></td>
    <td><code>rule</code></td>
    <td></td>
    <td><code>width</code> (Width from hlist)</td>
  </tr>
</tbody>
</table>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">head_node</span>
         Node # The head of a node list.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "add_additional_lines"></a>
    <strong>add_additional_lines (last_hlist_node, count)</strong>
    </dt>
    <dd>
    Add multiple empty lines at the end of a paragraph.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">last_hlist_node</span>
         HlistNode # The last hlist node of a paragraph.
        </li>
        <li><span class="parameter">count</span>
         number # Count of the lines to add at the end.
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Class_HlistNode"></a>Class HlistNode </h2>

    <dl class="function">
    <dt>
    <a name = "HlistNode.hlist_node"></a>
    <strong>HlistNode.hlist_node</strong>
    </dt>
    <dd>










</dd>
    <dt>
    <a name = "HlistNode.register"></a>
    <strong>HlistNode.register (callback_name, func, description)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">callback_name</span>
         CallbackName # The name of a callback
        </li>
        <li><span class="parameter">func</span>
         function # A function to register for the callback
        </li>
        <li><span class="parameter">description</span>
         string # Only used in LuaLatex
        </li>
    </ul>





</dd>
    <dt>
    <a name = "HlistNode.unregister"></a>
    <strong>HlistNode.unregister (callback_name, description)</strong>
    </dt>
    <dd>





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">callback_name</span>
         CallbackName # The name of a callback
        </li>
        <li><span class="parameter">description</span>
         string # Only used in LuaLatex
        </li>
    </ul>





</dd>
    <dt>
    <a name = "HlistNode.is_registered"></a>
    <strong>HlistNode.is_registered</strong>
    </dt>
    <dd>
    Store informations if the callbacks are already registered for
a certain mode (<code>basic</code>, <code>fix</code>, <code>par</code>). </p>

<p><code><pre>
is_registered = {
  fix = true,
  basic = false,
  par = false,
}</pre></code>







</dd>
    <dt>
    <a name = "HlistNode:register_callbacks"></a>
    <strong>HlistNode:register_callbacks (mode)</strong>
    </dt>
    <dd>
    Register the functions <a href="index.html#make_par">make_par</a>, <a href="index.html#make_basic">make_basic</a> and
<a href="index.html#make_fix">make_fix</a> as callbacks. </p>

<p><a href="index.html#make_par">make_par</a> and <a href="index.html#make_basic">make_basic</a> are registered to the callback
<code>post_linebreak_filter</code> and <a href="index.html#make_fix">make_fix</a> to the callback
<code>pre_linebreak_filter</code>. The argument <code>mode</code> accepts the string values
<code>basic</code>, <code>fix</code> and <code>par</code>. A special treatment is needed for clozes in
display math mode. The <code>post_linebreak_filter</code> is not called on
display math formulas. I’m not sure if the <code>pre_output_filter</code> is the
right choice to capture the display math formulas.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mode</span>
         MarkerMode
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        boolean|nil
    </ol>




</dd>
    <dt>
    <a name = "HlistNode:unregister_callbacks"></a>
    <strong>HlistNode:unregister_callbacks (mode)</strong>
    </dt>
    <dd>
    Delete the registered functions from the Lua callbacks.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mode</span>
         MarkerMode
        </li>
    </ul>





</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-01-03 23:34:09 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
